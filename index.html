<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>New Event</title>
<style>
  :root{--border:#d9d9d9;--muted:#666;--sold:#e53935;--avail:#2ecc71;}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#fff;color:#111;}
  header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:12px;}
  #status{font-size:13px;color:var(--muted);}
  .wrap{padding:12px;}
  .card{border:1px solid var(--border);border-radius:10px;overflow:hidden;background:#fff;}
  .cardHead{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);}
  .legend{display:flex;gap:10px;flex-wrap:wrap;padding:10px 12px;border-top:1px solid var(--border);}
  .pill{display:inline-flex;align-items:center;gap:8px;font-size:12px;color:#222;border:1px solid var(--border);padding:6px 8px;border-radius:999px;background:#fff;}
  .dot{width:10px;height:10px;border-radius:50%;}
  .dot.sold{background:var(--sold);} .dot.avail{background:var(--avail);}
  #svgHost{overflow:auto;min-height:420px;}
  #svgHost svg{width:100%;height:auto;display:block;}
  svg text, svg tspan{pointer-events:none;user-select:none;}
  #tooltip{position:fixed;display:none;z-index:9999;pointer-events:none;background:rgba(0,0,0,.85);color:#fff;padding:8px 10px;border-radius:8px;font-size:13px;white-space:pre-line;max-width:min(360px,85vw);}

  .soldSection{margin-top:12px;border:1px solid var(--border);border-radius:10px;padding:10px 12px;background:#fff;}
  .soldHeader{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
  .soldTitle{font-weight:900;font-size:22px;margin:10px 0 8px;}
  #soldSearch{flex:1;min-width:240px;padding:9px 10px;border:1px solid var(--border);border-radius:8px;font-size:16px;}
  .soldHint{margin-top:6px;font-size:12px;color:var(--muted);}
  .soldListWrap{margin-top:10px;border:1px solid var(--border);border-radius:10px;overflow:auto;max-height:360px;}
  .soldItem{display:flex;justify-content:space-between;gap:12px;align-items:center;padding:10px 12px;border-bottom:1px solid #eee;cursor:pointer;background:#fff;}
  .soldItem:nth-child(odd){background:#fafafa;}
  .soldItem:hover{background:#eef3ff;}
  .soldItem.active{background:#eaf0ff;outline:2px solid #b8c7ff;outline-offset:-2px;}
  .soldName{font-weight:700;font-size:13px;line-height:1.2;}
  .soldMeta{font-size:12px;color:var(--muted);white-space:nowrap;}


/* ===== Mobile: keep plan pinned, scroll exhibitors ===== */
@media (max-width: 820px){
  header{position:sticky;top:0;z-index:50;background:#fff;}
  body{overflow:hidden;}
  .wrap{
    padding:10px;
    height: calc(100vh - var(--headerH, 56px));
    overflow:hidden;
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .card{flex:0 0 auto;}
  /* Keep plan visible but not huge; avoid dead white space */
  #svgHost{min-height:260px;max-height:46vh;overflow:hidden;}
  #svgHost svg{height:100%;}
  /* Scroll everything under the plan */
  .soldSection{
    flex:1 1 auto;
    margin-top:0;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
  }
  .soldListWrap{max-height:none;}
}

@media print{
  header, .soldSection{display:none !important;}
  .wrap{padding:0;}
  .card{border:none;border-radius:0;}
  .legend{border-top:none;}
  #svgHost{min-height:auto;}
}

  .pdfOpts{margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px 12px;background:#fff;}
  .pdfGrid{margin-top:8px;display:grid;grid-template-columns:1.4fr 1fr 1fr 1.2fr;gap:10px;align-items:center;}
  .opt{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted);user-select:none;}
  .opt input[type="text"]{flex:1;min-width:180px;padding:8px 10px;border:1px solid var(--border);border-radius:8px;font-size:16px;color:#111;}
  .opt.chk{justify-content:flex-start;}
  .opt.chk input{width:16px;height:16px;}
  @media (max-width:900px){.pdfGrid{grid-template-columns:1fr 1fr;}}

  /* Pinned label column (scrollable, does NOT resize the map) */
  #svgHost{position:relative; overflow:visible;}
  #pinPanel{position:absolute;top:12px;right:24px;display:flex;flex-direction:column;gap:8px;max-width:calc(100% - 48px);z-index:5;pointer-events:none;box-sizing:border-box}
  /* Desktop: tidy column on right */
  #pinPanel .pinItem{background:rgba(229,62,62,.95);color:#fff;font-weight:700;border-radius:999px;padding:10px 14px;font-size:14px;line-height:1;box-shadow:0 2px 8px rgba(0,0,0,.18);pointer-events:auto;cursor:pointer;user-select:none;max-width:100%;width:100%;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;white-space:nowrap}
  /* Mobile: stack pins in the big white space under the plan */
  .mobileOnly{display:none;}
  @media (max-width: 820px){.mobileOnly{display:inline-flex;}}
  @media (max-width: 820px){
    #btnTogglePins{display:inline-block !important;}
    #pinPanel{
      left:16px;
      right:16px;
      top:auto;
      bottom:16px;
      width:auto;
      max-height:40%;
      background:rgba(255,255,255,0.92);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      box-shadow:0 8px 18px rgba(0,0,0,0.08);
    }
  }

  #pinPanel .pinItem{
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:8px 10px;
    border-radius:12px;
    background: var(--sold);
    color:#fff;
    font-weight:800;
    font-size:13px;
    line-height:1.15;
    user-select:none;
    cursor:pointer;
    word-break:break-word;
  }
  #pinPanel .pinItem.small{font-size:12px;font-weight:800;}
  #overlaySvg{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    z-index:4;
    pointer-events:none;
  }


  /* Public UX: remove manual zoom controls (auto-fit only) */
  #btnResetView,#btnFit,#btnZoomIn,#btnZoomOut{display:none !important;}
  /* Mobile: pins appear in the large white area under the plan */
  @media (max-width: 720px){
    #pinPanel{
      left:16px !important;
      right:16px !important;
      top:auto !important;
      bottom:16px !important;
      width:auto !important;
      max-height:96px !important;
    }
    #pinPanel .pinItem{ width:100%; text-align:center; }
  }

  /* Mobile UX tweaks */
  @media (max-width: 720px){
    .cardHead .title{ display:none; }
    #soldSearch{ font-size:16px; }
  }
  /* Keep the pin lozenge fully visible */
  #pinPanel{
    right:auto !important;
    left:52% !important;
    transform: translateX(-50%);
    max-width: calc(100% - 24px);
  }
  /* Give iOS address bar some breathing room */
  .soldCard{ padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 32px); }

</style>
</head>
<body>
<header>
  <strong id="eventNameText">New Event</strong>
  <div id="status">Loading…</div>
</header>

<div class="wrap">
  <div class="card">
    <div class="cardHead">
      <div style="font-weight:700;">Plan</div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;">
        <button id="btnClearPins" style="padding:8px 10px;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:pointer;font-weight:700;font-size:13px;">Clear pins</button>
        <button id="btnTogglePins" class="mobileOnly" style="padding:8px 10px;border:1px solid var(--border);background:#fff;border-radius:8px;cursor:pointer;font-weight:700;font-size:13px;">Pinned exhibitors</button>
        <button id="btnExportPdf" style="padding:8px 10px;border:1px solid var(--border);background:#f7f7f7;border-radius:8px;cursor:pointer;font-weight:700;font-size:13px;">Export PDF</button>
</div>
    </div>

    <div id="svgHost"></div>

    <!-- Public page: legend hidden on-map (still optional in PDF export) -->
  </div>

  <div class="soldSection">
<div class="soldHeader">
      <input id="soldSearch" type="text" placeholder="Search company or stand…" />
    </div>
<div class="soldHint">Click a company name to highlight its stand with a label and pointer line.</div>
    <div class="soldListWrap">
      <div id="soldList"></div>
    </div>
  </div>
</div>

<div id="tooltip"></div>

<script>
(() => {

  // Keep a CSS var for header height (for mobile pinned plan layout)
  function setHeaderHeightVar(){
    const h = document.querySelector('header');
    if (!h) return;
    document.documentElement.style.setProperty('--headerH', (h.getBoundingClientRect().height || h.offsetHeight || 56) + 'px');
  }
  window.addEventListener('resize', () => { try{ setHeaderHeightVar(); }catch(e){} }, {passive:true});
  // initial
  setHeaderHeightVar();

  // Safari compatibility: CSS.escape polyfill
  if (!window.CSS) window.CSS = {};
  if (typeof window.CSS.escape !== 'function') {
    window.CSS.escape = function (value) {
      return String(value).replace(/[^a-zA-Z0-9_\-]/g, function (ch) {
        const hex = ch.codePointAt(0).toString(16).toUpperCase();
        return '\\' + hex + ' ';
      });
    };
  }

  const API_BASE = 'https://floorplansaberdeen.floorplansaberdeen.workers.dev';
  const SVG_URL = './event_plan.svg';
  const FILL_OPACITY = 0.75;
  const SYNC_INTERVAL_MS = 10000;
  const SOLD = '#e53935';
  const AVAIL = '#2ecc71';

  const elStatus = document.getElementById('status');
  const svgHost = document.getElementById('svgHost');
  const tooltip = document.getElementById('tooltip');
  const soldListEl = document.getElementById('soldList');
  const soldSearchEl = document.getElementById('soldSearch');
  const btnClearPins = document.getElementById('btnClearPins');
  const btnTogglePins = document.getElementById('btnTogglePins');
  const btnExportPdf = document.getElementById('btnExportPdf');
  const PDF_DEFAULTS = { includePins:true, includeLegend:true, includeSoldList:true };
  let eventName = 'New Event';
  function applyEventName(name){
    const n = String(name||'').trim();
    if(!n) return;
    eventName = n;
    document.title = eventName;
    const h = document.getElementById('eventNameText');
    if(h) h.textContent = eventName;
  }

  let svgRoot = null;
  let baseViewBox = null;
  let autoViewBox = null;
  let userViewChanged = false;
  const pointers = new Map();
  let gesture = {mode:null, startVB:null, startPt:null, startDist:0, startCenter:null, moved:false};
  let byId = new Map(); // standId -> {standId,status,company}
  let calloutLayer = null;
  let pinPanelEl = null;
  let overlaySvgEl = null;
  let lastPinsRendered = [];
  let pinned = new Set();
  let bboxCache = new Map();
  let pinsRaf = 0;
  let linesRaf = 0;
  let pinsPanelVisible = true; // mobile toggle

  // Stand IDs look like: A1, AA1, AB2, AD10, SB20, C6 etc.
  const STAND_ID_RE = /^([A-Z]{1,3})(\d{1,3})$/;
  const IS_TOUCH = (window.matchMedia && window.matchMedia('(hover: none)').matches) || ('ontouchstart' in window);


  function setStatus(text, isError=false){
    elStatus.textContent = text;
    elStatus.style.color = isError ? '#b00020' : '#555';
  }

  function normalizeStatus(v){
    return String(v||'').toLowerCase().trim()==='sold' ? 'sold' : 'available';
  }

  function tooltipText(info){
    const s = normalizeStatus(info.status);
    const lines = [info.standId, s==='sold' ? 'Sold' : 'Available'];
    if (s==='sold' && info.company) lines.push(info.company);
    return lines.join('\n');
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  
  
  function scheduleRenderPins(){
    if (pinsRaf) return;
    pinsRaf = requestAnimationFrame(() => {
      pinsRaf = 0;
      renderPins();
      updatePinUi();
    });
  }

function scheduleUpdateLines(){
    if (linesRaf) return;
    linesRaf = requestAnimationFrame(() => {
      linesRaf = 0;
      updateOverlayLines();
    });
  }

  
  function warmBBoxCache(){
    // Precompute a few stand bounding boxes per frame to avoid Safari freezing on first click
    const nodes = getStandNodes();
    let i = 0;
    function step(){
      const start = performance.now();
      // up to ~8ms per frame
      while (i < nodes.length && (performance.now() - start) < 8){
        const id = String(nodes[i].id || '').trim();
        if (id) getStandBox(id);
        i++;
      }
      if (i < nodes.length) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

function getStandBox(standId){
    if (bboxCache.has(standId)) return bboxCache.get(standId);
    const node = svgRoot.querySelector('#' + CSS.escape(standId));
    if (!node) return null;
    try{
      const bb = node.getBBox();
      const info = { bb, cx: bb.x + bb.width/2, cy: bb.y + bb.height/2 };
      bboxCache.set(standId, info);
      return info;
    }catch{
      return null;
    }
  }

function splitLines(text, maxChars){
    const s = String(text || '').trim();
    if (!s) return [''];
    const words = s.split(/\s+/);
    const lines = [];
    let cur = '';
    for (const w of words){
      if (!cur){
        cur = w;
      } else if ((cur + ' ' + w).length <= maxChars){
        cur += ' ' + w;
      } else {
        lines.push(cur);
        cur = w;
      }
    }
    if (cur) lines.push(cur);
    // hard-break very long single words
    const out = [];
    for (const ln of lines){
      if (ln.length <= maxChars) out.push(ln);
      else{
        for (let i=0;i<ln.length;i+=maxChars) out.push(ln.slice(i,i+maxChars));
      }
    }
    return out.slice(0, 3); // keep labels compact
  }

async function fetchJson(url){
    const res = await fetch(url, { cache:'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return await res.json();
  }

  async function loadSvg(){
    const res = await fetch(SVG_URL, { cache:'no-store' });
    if (!res.ok) throw new Error('SVG not found at ' + SVG_URL + ' (HTTP ' + res.status + ')');
    svgHost.innerHTML = await res.text();
    svgRoot = svgHost.querySelector('svg');
    if (!svgRoot) throw new Error('SVG root <svg> not found');
    svgRoot.style.userSelect = 'none';
  }

  function isStandId(id){
    const s = String(id||'').trim();
    return STAND_ID_RE.test(s);
  }

  function getStandNodes(){
    // Prefer <g id="A1"> groups, else shapes with id.
    const groups = Array.from(svgRoot.querySelectorAll('g[id]'))
      .filter(g => isStandId(g.id));
    const shapes = Array.from(svgRoot.querySelectorAll('path[id],rect[id],polygon[id],circle[id],ellipse[id],polyline[id],line[id]'))
      .filter(el => isStandId(el.id));
    return groups.length ? groups : shapes;
  }

  // expose for any legacy calls
  window.getStandNodes = function(){
    if(!svgRoot) return [];
    return getStandNodes();
  };

  function paintNode(node, status){
    const s = normalizeStatus(status);
    const color = s==='sold' ? SOLD : AVAIL;
    const targets = (node.tagName.toLowerCase()==='g')
      ? node.querySelectorAll('path,rect,polygon,circle,ellipse,polyline,line')
      : [node];

    targets.forEach(el => {
      el.style.fill = color;
      el.style.fillOpacity = String(FILL_OPACITY);
      el.style.stroke = 'rgba(0,0,0,0.45)';
      el.style.strokeOpacity = '0.6';
      el.style.cursor = 'pointer';
    });
  }

  function svgEl(tag, attrs={}){
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }

  function ensureCalloutLayer(){
    if (!svgRoot) return;
    if (!calloutLayer){
      calloutLayer = svgEl('g', { id:'callouts' });
      svgRoot.appendChild(calloutLayer);
    }
  }

  function ensureOverlay(){
    if (!svgHost) return;
    if (!pinPanelEl){
      pinPanelEl = document.createElement('div');
      pinPanelEl.id = 'pinPanel';
      svgHost.appendChild(pinPanelEl);
      pinPanelEl.addEventListener('scroll', () => scheduleUpdateLines());
    }
    if (!overlaySvgEl){
      overlaySvgEl = document.createElementNS('http://www.w3.org/2000/svg','svg');
      overlaySvgEl.setAttribute('id','overlaySvg');
      overlaySvgEl.setAttribute('xmlns','http://www.w3.org/2000/svg');
      overlaySvgEl.setAttribute('preserveAspectRatio','none');
      svgHost.appendChild(overlaySvgEl);
      // keep overlay sized to host
      const ro = new ResizeObserver(() => scheduleRenderPins());
      ro.observe(svgHost);
    }
  }

  function clearOverlay(){
    if (overlaySvgEl) overlaySvgEl.innerHTML = '';
    if (pinPanelEl){
      pinPanelEl.innerHTML = '';
      pinPanelEl.style.display = 'none';
    }
    lastPinsRendered = [];
  }

  function clearPins(){
    pinned.clear();
    soldListEl?.querySelectorAll('.soldItem.active').forEach(x=>x.classList.remove('active'));
    clearOverlay();
    updatePinUi();
    // When no pins, return to the largest (plan-only) fit unless the user manually panned/zoomed.
    if (!userViewChanged && initialFitViewBox){
      applyViewBox(initialFitViewBox);
    }
    scheduleRenderPins();
    renderSoldList();
  }

  function togglePin(standId){
    // Single active pin: selecting a new stand replaces the previous one.
    if (pinned.has(standId)) {
      pinned.clear();
    } else {
      pinned.clear();
      pinned.add(standId);
    }
    // If we just removed the last pin, snap back to the plan-only fit.
    if (!pinned.size && !userViewChanged && initialFitViewBox){
      applyViewBox(initialFitViewBox);
    }
    scheduleRenderPins();
    renderSoldList();
  }

    
  // ===== ViewBox / Pan-Zoom helpers (clean for iOS Safari) =====

  function isMobile(){
    return window.matchMedia && window.matchMedia("(max-width: 820px)").matches;
  }

  function updatePinUi(){
    if (!pinPanelEl) return;
    const mobile = isMobile();
    if (btnTogglePins){
      btnTogglePins.style.display = (mobile && pinned.size) ? "inline-flex" : "none";
      if (mobile && pinned.size){
        btnTogglePins.textContent = (pinsPanelVisible ? "Hide pinned (" : "Show pinned (") + pinned.size + ")";
      }
    }

    if (!pinned.size){
      pinPanelEl.style.display = "none";
      if (overlaySvgEl) overlaySvgEl.style.display = "none";
      return;
    }

    if (mobile && !pinsPanelVisible){
      pinPanelEl.style.display = "none";
      if (overlaySvgEl) overlaySvgEl.style.display = "none";
    }else{
      pinPanelEl.style.display = "flex";
      if (overlaySvgEl) overlaySvgEl.style.display = "block";
    }
  }

  function getViewBox(){
    try{
      const vbAttr = svgRoot && svgRoot.getAttribute ? svgRoot.getAttribute('viewBox') : null;
      if (vbAttr){
        const p = vbAttr.trim().split(/[ ,]+/).map(Number);
        if (p.length===4 && p.every(n=>Number.isFinite(n))) return {x:p[0], y:p[1], w:p[2], h:p[3]};
      }
    }catch{}

    try{
      const vb = svgRoot && svgRoot.viewBox && svgRoot.viewBox.baseVal ? svgRoot.viewBox.baseVal : null;
      if (vb && Number.isFinite(vb.width) && vb.width>0) return {x:vb.x, y:vb.y, w:vb.width, h:vb.height};
    }catch{}

    try{
      const b = svgRoot.getBBox();
      if (b && Number.isFinite(b.width) && b.width>0) return {x:b.x, y:b.y, w:b.width, h:b.height};
    }catch{}

    return {x:0,y:0,w:2000,h:2000};
  }

  function applyViewBox(vb){
    if (!svgRoot) return;
    const o = {x:Number(vb.x)||0, y:Number(vb.y)||0, w:Number(vb.w ?? vb.width)||1000, h:Number(vb.h ?? vb.height)||1000};
    svgRoot.setAttribute('viewBox', `${o.x} ${o.y} ${o.w} ${o.h}`);
  }

  function currentViewBox(){
    return getViewBox();
  }

  function initBaseViewBox(){
    const vb = currentViewBox();
    baseViewBox = {x:vb.x, y:vb.y, w:vb.w, h:vb.h};
    autoViewBox = {x:vb.x, y:vb.y, w:vb.w, h:vb.h};
  }

  function clientToSvg(clientX, clientY){
    if (!svgRoot) return null;
    const ctm = svgRoot.getScreenCTM?.();
    if (!ctm) return null;
    const pt = svgRoot.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const p = pt.matrixTransform(ctm.inverse());
    return {x:p.x, y:p.y};
  }

  function zoomAt(clientX, clientY, factor){
    const p = clientToSvg(clientX, clientY);
    if (!p) return;
    const vb = currentViewBox();

    const newW = Math.max(200, vb.w * factor);
    const newH = Math.max(200, vb.h * factor);

    const rx = (p.x - vb.x) / vb.w;
    const ry = (p.y - vb.y) / vb.h;

    const nx = p.x - rx * newW;
    const ny = p.y - ry * newH;

    userViewChanged = true;
    applyViewBox({x:nx, y:ny, w:newW, h:newH});
    scheduleRenderPins();
  }

  function resetView(){
    userViewChanged = false;
    autoViewBox = null;
    if (baseViewBox) applyViewBox(baseViewBox);
    scheduleRenderPins();
  }

  // Remember the "natural" fit (plan only) so we can snap back when no exhibitors are pinned.
  let initialFitViewBox = null;

  function isNarrowLayout(){
    const w = (svgHost && svgHost.getBoundingClientRect) ? svgHost.getBoundingClientRect().width : window.innerWidth;
    return w < 720;
  }

  function fitToScreen(){
    // Fit to the plan only (no label space). This should be the biggest-looking plan on phones.
    userViewChanged = false;
    autoViewBox = null;

    if (!svgRoot) return;

    const vbBase = baseViewBox || getViewBox();
    const plan = computePlanBounds();
    const pad = plan ? Math.max(18, Math.round(Math.max(plan.w, plan.h) * 0.06)) : 20;

    let x = plan ? (plan.minX - pad) : vbBase.x;
    let y = plan ? (plan.minY - pad) : vbBase.y;
    let w = plan ? (plan.w + pad*2) : vbBase.w;
    let h = plan ? (plan.h + pad*2) : vbBase.h;

    const vb = {x, y, w, h};
    applyViewBox(vb);
    // Only capture this as the "initial" fit when nothing is pinned.
    if (!pinned.size) initialFitViewBox = {...vb};
    scheduleRenderPins();
  }

  function computePlanBounds(){
    // Union of all stand bboxes (not the whole svg) – used to place labels outside the plan.
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const nodes = getStandNodes();
    for (const n of nodes){
      const id = String(n.id||'').trim();
      if (!id) continue;
      const b = getStandBox(id);
      if (!b) continue;
      const bb = b.bb;
      minX = Math.min(minX, bb.x);
      minY = Math.min(minY, bb.y);
      maxX = Math.max(maxX, bb.x + bb.width);
      maxY = Math.max(maxY, bb.y + bb.height);
    }
    if (!Number.isFinite(minX)) return null;
    return {minX, minY, maxX, maxY, w:maxX-minX, h:maxY-minY};
  }

  function renderPins(){
    ensureOverlay();
    if (!svgRoot || !svgHost) return;

    // If no pins, clear overlays (and keep map at initial fit unless user changed view)
    if (!pinned.size){
      clearOverlay();
    updatePinUi();
      return;
    }

    // Only show pins for sold stands that have company names
    const pins = Array.from(pinned)
      .map(id => byId.get(id))
      .filter(info => info && normalizeStatus(info.status)==='sold' && info.company);

    if (!pins.length){
      pinned.clear();
      clearOverlay();
    updatePinUi();
      return;
    }

    // Build ordered list (top-to-bottom stand position)
    const pinsWithBox = [];
    for (const info of pins){
      const box = getStandBox(info.standId);
      if (!box) continue;
      pinsWithBox.push({info, cx: box.cx, cy: box.cy});
    }
    pinsWithBox.sort((a,b)=> (a.cy-b.cy) || (a.cx-b.cx));

    const pinsToShow = pinsWithBox.slice(0, 200); // cap for responsiveness
    lastPinsRendered = pinsToShow.map(p=>p.info.standId);

    // Preserve scroll position while rebuilding
    const prevScroll = pinPanelEl ? pinPanelEl.scrollTop : 0;

    // Build HTML label column (single tidy column, scrollable)
    if (pinPanelEl){
      pinPanelEl.style.display = 'flex';
      pinPanelEl.style.flexDirection = 'column';
      pinPanelEl.style.alignItems = 'stretch';
      pinPanelEl.style.gap = '10px';
      pinPanelEl.style.left = '';
      pinPanelEl.style.right = '12px'; // RIGHT side as requested
      pinPanelEl.innerHTML = '';
      for (const p of pinsToShow){
        const div = document.createElement('div');
        div.className = 'pinItem';
        // Slightly smaller font for long names, keep centered
        if (String(p.info.company).length > 18) div.classList.add('small');
        div.textContent = p.info.company;
        div.title = `${p.info.company} (${p.info.standId})`;
        div.dataset.standId = p.info.standId;
        div.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Clicking a pin label scrolls the sold list to it (if visible)
          const row = soldListEl?.querySelector(`[data-stand="${CSS.escape(p.info.standId)}"]`);
          if (row && row.scrollIntoView) row.scrollIntoView({block:'center', behavior:'smooth'});
        });
        pinPanelEl.appendChild(div);
      }
      // restore scroll (clamped)
      pinPanelEl.scrollTop = Math.min(prevScroll, pinPanelEl.scrollHeight);
    }

    // Draw pointer lines on overlay SVG (in pixel space)
    scheduleUpdateLines();
  }

  function updateOverlayLines(){
    if (!overlaySvgEl || !svgRoot || !svgHost) return;
    if (!pinned.size || !lastPinsRendered.length){
      overlaySvgEl.innerHTML = '';
      return;
    }

    const hostRect = svgHost.getBoundingClientRect();
    const w = Math.max(1, Math.round(hostRect.width));
    const h = Math.max(1, Math.round(hostRect.height));

    overlaySvgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
    overlaySvgEl.innerHTML = '';

    // Build quick lookup from standId -> pin label element
    const labelEls = new Map();
    if (pinPanelEl){
      for (const el of Array.from(pinPanelEl.querySelectorAll('.pinItem'))){
        const id = String(el.dataset.standId||'').trim();
        if (id) labelEls.set(id, el);
      }
    }

    const frag = document.createDocumentFragment();

    for (const standId of lastPinsRendered){
      const info = byId.get(standId);
      if (!info || normalizeStatus(info.status)!=='sold' || !info.company) continue;

      const standNode = svgRoot.querySelector('#' + CSS.escape(standId));
      const labelEl = labelEls.get(standId);
      if (!standNode || !labelEl) continue;

      const standRect = standNode.getBoundingClientRect();
      const labelRect = labelEl.getBoundingClientRect();

      const x1 = (standRect.left - hostRect.left) + standRect.width/2;
      const y1 = (standRect.top  - hostRect.top)  + standRect.height/2;

      // Line ends at centre of the label pill
      const x2 = (labelRect.left - hostRect.left) + labelRect.width/2;
      const y2 = (labelRect.top  - hostRect.top)  + labelRect.height/2;

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', x1.toFixed(2));
      line.setAttribute('y1', y1.toFixed(2));
      line.setAttribute('x2', x2.toFixed(2));
      line.setAttribute('y2', y2.toFixed(2));
      line.setAttribute('stroke', '#111');
      line.setAttribute('stroke-width', '1');
      line.setAttribute('stroke-linecap','round');
      line.style.opacity = '0.85';
      frag.appendChild(line);
    }

    overlaySvgEl.appendChild(frag);
  }

  function bindNodeEvents(node){
    const standId = String(node.id||'').trim();
    if (!standId) return;

    // iOS/Safari can freeze on SVG hit-testing; on touch devices we disable map interaction
    // and rely on the exhibitor list/search for selection.
    if (IS_TOUCH){
      return;
    }

    node.addEventListener('mousemove', e => {
      const info = byId.get(standId) || { standId, status:'available', company:'' };
      tooltip.textContent = tooltipText(info);
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top  = (e.clientY + 12) + 'px';
      tooltip.style.display = 'block';
    });
    node.addEventListener('mouseleave', () => tooltip.style.display = 'none');

    node.addEventListener('click', () => {
      const info = byId.get(standId);
      if (info && normalizeStatus(info.status)==='sold' && info.company){
        togglePin(standId);
      }
    });
  }

  function renderPlan(){
    getStandNodes().forEach(node => {
      const id = String(node.id||'').trim();
      const info = byId.get(id) || { standId:id, status:'available', company:'' };
      paintNode(node, info.status);
    });
  }

  function renderSoldList(){
    const q = String(soldSearchEl.value||'').toLowerCase().trim();
    const sold = Array.from(byId.values())
      .filter(r => normalizeStatus(r.status)==='sold' && r.company)
      .sort((a,b) => a.company.localeCompare(b.company));

    const filtered = q ? sold.filter(r => r.company.toLowerCase().includes(q) || r.standId.toLowerCase().includes(q)) : sold;

    soldListEl.innerHTML = '';
    filtered.forEach(r => {
      const div = document.createElement('div');
      div.className = 'soldItem' + (pinned.has(r.standId) ? ' active' : '');
      div.dataset.standId = r.standId;
      div.innerHTML = `<div class="soldName">${escapeHtml(r.company)}</div><div class="soldMeta">Stand ${escapeHtml(r.standId)}</div>`;
      div.addEventListener('click', () => {
        togglePin(r.standId);
      });
      soldListEl.appendChild(div);
    });

    if (!filtered.length){
      soldListEl.innerHTML = '<div style="padding:12px;color:#666;">No sold companies yet.</div>';
    }
  }

  async function syncOnce(){
    try{
      const data = await fetchJson(API_BASE + '/stands?ts=' + Date.now());
      const stands = Array.isArray(data) ? data : (data && Array.isArray(data.stands) ? data.stands : []);
      if(data && !Array.isArray(data) && typeof data.eventName === 'string') applyEventName(data.eventName);
      byId = new Map(stands.map(r => [String(r.standId).trim(), {
        standId:String(r.standId).trim(),
        status:normalizeStatus(r.status),
        company:String(r.company||'').trim()
      }]));

      renderPlan();
      renderSoldList();
      scheduleRenderPins();

      setStatus('Synced: ' + new Date().toLocaleTimeString());
    }catch(e){
      setStatus('Sync error: ' + e.message, true);
      console.error(e);
    }
  }

  (async () => {
    try{
      setStatus('Loading…');
await loadSvg();
      // Load shared settings (event name) from backend
      try{
        const s = await fetchJson(API_BASE + '/settings?ts=' + Date.now());
        if(s && typeof s.eventName === 'string') applyEventName(s.eventName);
      }catch(_){/* ignore */}

      bboxCache = new Map();
      warmBBoxCache();
      ensureCalloutLayer();
      initBaseViewBox();
      // Start with the largest "plan-only" fit.
      fitToScreen();
      getStandNodes().forEach(bindNodeEvents);

      soldSearchEl.addEventListener('input', renderSoldList);

      btnClearPins?.addEventListener('click', () => { clearPins(); renderSoldList(); });

      btnTogglePins?.addEventListener('click', () => {
        pinsPanelVisible = !pinsPanelVisible;
        try{ sessionStorage.setItem('fp_pinsVisible', pinsPanelVisible ? '1' : '0'); }catch{}
        updatePinUi();
        scheduleRenderPins();
      });

      try{
        const savedPins = sessionStorage.getItem('fp_pinsVisible');
        if (savedPins === '0') pinsPanelVisible = false;
      }catch{}
      updatePinUi();
      
      
      
      btnExportPdf?.addEventListener('click', () => {
        if (!svgRoot) return;

        const includePins = !!(chkPinsPdf && PDF_DEFAULTS.includePins);
        const includeSoldList = !!(chkSoldListPdf && PDF_DEFAULTS.includeSoldList);
        const includeLegend = !!(chkLegendPdf && PDF_DEFAULTS.includeLegend);

        const rawEventName = (eventNameEl && eventName) ? eventName : 'Exhibition Floorplan';
        const eventName = String(rawEventName).trim() || 'Exhibition Floorplan';

        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth()+1).padStart(2,'0');
        const dd = String(d.getDate()).padStart(2,'0');
        const dateStr = `${yyyy}-${mm}-${dd}`;
        const suggested = `${eventName.replace(/\s+/g,' ').trim()} ${dateStr}`;

        const w = window.open('', '_blank');

        // Clone SVG so we can optionally remove pins for PDF
        const clone = svgRoot.cloneNode(true);
        if (!includePins){
          const pins = clone.querySelector('#callouts');
          if (pins) pins.remove();
        }

        // Make sure SVG scales well in print (vector = high-res)
        clone.removeAttribute('width');
        clone.removeAttribute('height');
        clone.setAttribute('preserveAspectRatio','xMidYMid meet');
        clone.style.width = '100%';
        clone.style.height = 'auto';

        const svgHtml = clone.outerHTML;

        // Build sold list HTML (optional)
        let legendHtml = '';
        if (includeLegend){
          legendHtml = `<div class="legendBox">
            <div class="lg"><span class="dot sold"></span><span>Sold</span></div>
            <div class="lg"><span class="dot avail"></span><span>Available</span></div>
          </div>`;
        }

        let soldHtml = '';
        if (includeSoldList){
          const sold = Array.from(byId.values())
            .filter(r => normalizeStatus(r.status)==='sold' && r.company)
            .sort((a,b)=>a.company.localeCompare(b.company));

          if (sold.length){
            const rows = sold.map(r => `<div class="sRow"><div class="sName">${escapeHtml(r.company)}</div><div class="sStand">Stand ${escapeHtml(r.standId)}</div></div>`).join('');
            soldHtml = `<div class="soldBox">
${rows}
            </div>`;
          }
        }

        w.document.write(`<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>${suggested}</title>
<style>
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#fff;color:#111;}
  .top{padding:12px;border-bottom:1px solid #ccc;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;}
  button{padding:10px 14px;font-size:14px;font-weight:800;border-radius:10px;border:1px solid #ccc;cursor:pointer;background:#f7f7f7;}
  .meta{font-size:13px;color:#444;}
  .wrap{padding:12px;}
  .frame{max-width:1400px;margin:0 auto;display:grid;grid-template-columns: 1fr;gap:12px;}
  svg{width:100%;height:auto;display:block;}

  .legendBox{display:flex;gap:14px;align-items:center;border:1px solid #ddd;border-radius:10px;padding:8px 10px;justify-content:flex-start;}
.lg{display:flex;gap:8px;align-items:center;font-size:12px;font-weight:800;}
.dot{width:10px;height:10px;border-radius:50%;display:inline-block;}
.dot.sold{background:#e53935;}
.dot.avail{background:#2ecc71;}
.soldBox{border:1px solid #ddd;border-radius:10px;padding:10px 12px;}
  .soldTitle{font-weight:900;margin-bottom:8px;}
  .sRow{display:flex;justify-content:space-between;gap:10px;padding:6px 0;border-bottom:1px solid #eee;}
  .sRow:last-child{border-bottom:none;}
  .sName{font-weight:700;font-size:12px;}
  .sStand{font-size:12px;color:#444;white-space:nowrap;}

  @page{ size: A4 landscape; margin: 10mm; }
  @media print{
    .top{display:none;}
    .wrap{padding:0;}
    .frame{max-width:none;}
  }

  .pdfOpts{margin-top:10px;border:1px solid var(--border);border-radius:10px;padding:10px 12px;background:#fff;}
  .pdfGrid{margin-top:8px;display:grid;grid-template-columns:1.4fr 1fr 1fr 1.2fr;gap:10px;align-items:center;}
  .opt{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted);user-select:none;}
  .opt input[type="text"]{flex:1;min-width:180px;padding:8px 10px;border:1px solid var(--border);border-radius:8px;font-size:16px;color:#111;}
  .opt.chk{justify-content:flex-start;}
  .opt.chk input{width:16px;height:16px;}
  @media (max-width:900px){.pdfGrid{grid-template-columns:1fr 1fr;}}
</style>
</head>
<body>
  <div class="top">
    <div>
      <div style="font-weight:900;">Export floorplan</div>
      <div class="meta">Suggested filename: <strong>${suggested}.pdf</strong></div>
      <div class="meta">Pins in PDF: <strong>${includePins ? 'Included' : 'Excluded'}</strong> • Legend: <strong>${includeLegend ? 'Included' : 'Excluded'}</strong> • Sold list: <strong>${includeSoldList ? 'Included' : 'Excluded'}</strong></div>
    </div>
    <button onclick="window.print()">Save as PDF</button>
  </div>
  <div class="wrap">
    <div class="frame">
      ${svgHtml}
      ${legendHtml}
      ${soldHtml}
    </div>
  </div>
</body>
</html>`);
        w.document.close();
      });
await syncOnce();
      setInterval(syncOnce, SYNC_INTERVAL_MS);
    }catch(e){
      setStatus('Load error: ' + e.message, true);
      console.error(e);
    }
  })();
})();
</script>
</body>
</html>
