<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Exhibition Floorplan</title>
<style>
  :root{
    --border:#e3e3e3;
    --muted:#666;
    --bg:#fafafa;

    /* Stand colours */
    --stand: rgba(213,109,50,0.75);
    --selected: rgba(229,57,53,0.92);

    --panel:#fff;
  }

  *{box-sizing:border-box}
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#fff;color:#111;}
  header{
    display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
    padding:14px 16px;border-bottom:1px solid var(--border);background:#fff;
  }
  .hleft{min-width:200px}
  #eventTitle{font-size:26px;font-weight:900;margin:0;line-height:1.1}
  #updated{margin-top:4px;color:var(--muted);font-size:13px}
  #statusLine{margin-top:6px;font-size:14px;font-weight:700}
  .ok{color:#0f7a2a}
  .bad{color:#b00020}

  .hright{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{
    padding:10px 12px;border:1px solid var(--border);
    background:#f7f7f7;border-radius:10px;cursor:pointer;
    font-weight:800;font-size:14px;
  }
  .btn:disabled{opacity:.5;cursor:not-allowed}

  .wrap{
    display:grid;
    grid-template-columns: 2.3fr 1fr;
    gap:12px;
    padding:12px;
  }
  @media (max-width: 980px){
    .wrap{grid-template-columns: 1fr;}
  }

  .card{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:16px;
    overflow:hidden;
    position:relative;
  }

  /* PLAN CARD */
  .planCard{
    min-height:520px;
  }
  .planInner{
    position:relative;
    width:100%;
    height:100%;
    min-height:520px;
    background:#fff;
  }
  #planHost{
    position:absolute; inset:0;
    overflow:hidden;
  }
  #planHost svg{width:100%;height:100%;display:block}
  #overlaySvg{
    position:absolute; inset:0;
    width:100%; height:100%;
    pointer-events:none;
  }

  /* legend pill */
  .legendPill{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom: 18px;
    display:flex;gap:18px;align-items:center;
    background:#fff;
    border:1px solid var(--border);
    border-radius:999px;
    padding:10px 16px;
    box-shadow:0 8px 18px rgba(0,0,0,.08);
    font-weight:800;
    user-select:none;
  }
  .dot{width:12px;height:12px;border-radius:50%}
  .dot.stand{background: rgba(213,109,50,0.95)}
  .dot.sel{background: rgba(229,57,53,0.95)}

  /* SIDE PANEL */
  .side{
    padding:12px;
    display:grid;
    gap:12px;
  }
  .panel{
    border:1px solid var(--border);
    border-radius:16px;
    padding:12px;
    background:#fff;
  }
  .panel h3{margin:0 0 8px 0;font-size:15px}
  .selBox strong{display:block;font-size:30px;letter-spacing:.3px}
  .selBox .co{font-size:18px;font-weight:800;margin-top:2px}
  .help{font-size:13px;color:var(--muted);line-height:1.35;margin-top:8px}
  .searchRow{
    display:flex; gap:10px; align-items:center;
  }
  #q{
    width:100%;
    padding:10px 12px;
    border:1px solid var(--border);
    border-radius:12px;
    font-size:15px;
  }
  .list{
    margin-top:10px;
    border:1px solid var(--border);
    border-radius:14px;
    overflow:auto;
    max-height: 420px;
    background:#fff;
  }
  .item{
    padding:10px 12px;
    border-bottom:1px solid #efefef;
    cursor:pointer;
  }
  .item:last-child{border-bottom:0}
  .item:hover{background:#fafafa}
  .item .name{font-weight:900}
  .item .meta{font-size:12px;color:var(--muted);margin-top:2px}
  .empty{padding:14px;color:var(--muted);font-size:13px}

  /* MOBILE: keep plan visible at top; list scrolls below */
  @media (max-width: 820px){
    header{gap:10px}
    #eventTitle{font-size:24px}
    .wrap{padding:10px;gap:10px}
    .planCard{min-height:420px}

    /* sticky plan */
    .planCard{
      position:sticky;
      top: 0;
      z-index: 5;
    }
    .planInner{min-height:420px}
    .list{max-height: 360px}

    /* smaller label by scaling overlay elements a touch */
    /* (overlay label is in SVG units; we scale the whole overlay visually on phones) */
    #overlaySvg{
      transform: scale(0.90);
      transform-origin: 50% 50%;
    }

    /* raise legend so Safari UI doesn't clip it */
    .legendPill{
      bottom: calc(34px + env(safe-area-inset-bottom));
    }
    .planInner{
      padding-bottom: calc(68px + env(safe-area-inset-bottom));
    }
  }
</style>
</head>
<body>

<header>
  <div class="hleft">
    <div id="eventTitle">Loading…</div>
    <div id="updated">Updated: —</div>
    <div id="statusLine"><span class="bad">Loading…</span></div>
  </div>
  <div class="hright">
    <button class="btn" id="btnPdf">Export PDF</button>
    <button class="btn" id="btnClear">Clear selection</button>
  </div>
</header>

<div class="wrap">
  <div class="card planCard">
    <div class="planInner">
      <div id="planHost"></div>
      <svg id="overlaySvg"></svg>

      <div class="legendPill">
        <span style="display:flex;align-items:center;gap:10px;"><span class="dot stand"></span> Stands</span>
        <span style="display:flex;align-items:center;gap:10px;"><span class="dot sel"></span> Selected</span>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="side">
      <div class="panel selBox">
        <h3>Selected exhibitor</h3>
        <strong id="selStand">None</strong>
        <div class="co" id="selCompany"></div>
        <div class="help">
          Desktop: click a stand or choose from the list.<br>
          Phone: use the list (stand tapping is disabled).
        </div>
      </div>

      <div class="panel">
        <h3>Sold exhibitors</h3>
        <div class="searchRow">
          <input id="q" type="text" placeholder="Search company or stand…" />
        </div>
        <div class="list" id="list"></div>
      </div>

      <div class="panel">
        <h3>Help</h3>
        <div class="help">
          All stands are in the main colour. Selecting an exhibitor makes their stand red with a label + line.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const API_BASE = 'https://floorplansaberdeen.floorplansaberdeen.workers.dev';
  const SVG_URL  = './event_plan.svg';

  const STAND_FILL    = getComputedStyle(document.documentElement).getPropertyValue('--stand').trim() || 'rgba(213,109,50,0.75)';
  const SELECTED_FILL = getComputedStyle(document.documentElement).getPropertyValue('--selected').trim() || 'rgba(229,57,53,0.92)';

  const elTitle   = document.getElementById('eventTitle');
  const elUpdated = document.getElementById('updated');
  const elStatus  = document.getElementById('statusLine');

  const planHost  = document.getElementById('planHost');
  const overlay   = document.getElementById('overlaySvg');

  const selStand  = document.getElementById('selStand');
  const selCompany= document.getElementById('selCompany');

  const qEl       = document.getElementById('q');
  const listEl    = document.getElementById('list');

  const btnClear  = document.getElementById('btnClear');
  const btnPdf    = document.getElementById('btnPdf');

  let svgRoot = null;
  let viewBox = null;

  let stands = [];               // raw from API
  let byId = new Map();          // standId -> {standId,status,company}
  let selectedId = '';           // one selection only

  const isPhone = matchMedia('(max-width: 820px)').matches;

  function setStatus(text, ok=true){
    elStatus.innerHTML = ok ? `<span class="ok">${escapeHtml(text)} ✅</span>` : `<span class="bad">${escapeHtml(text)}</span>`;
  }

  function escapeHtml(s){
    return String(s ?? '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  function normalizeStatus(v){
    return String(v||'').toLowerCase().trim() === 'sold' ? 'sold' : 'available';
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache: 'no-store' });
    const text = await res.text();
    let json;
    try{ json = JSON.parse(text); }catch(e){
      throw new Error('Bad JSON from server');
    }
    if(!res.ok) throw new Error('HTTP ' + res.status);
    return json;
  }

  async function loadSettings(){
    try{
      const s = await fetchJson(API_BASE + '/settings?ts=' + Date.now());
      const name = (s && typeof s.eventName === 'string' && s.eventName.trim()) ? s.eventName.trim() : 'New Event';
      elTitle.textContent = name;
    }catch{
      elTitle.textContent = 'New Event';
    }
  }

  async function loadSvg(){
    const res = await fetch(SVG_URL, { cache: 'no-store' });
    if(!res.ok) throw new Error('SVG not found at ' + SVG_URL);
    planHost.innerHTML = await res.text();
    svgRoot = planHost.querySelector('svg');
    if(!svgRoot) throw new Error('SVG root <svg> not found');

    // make responsive
    svgRoot.removeAttribute('width');
    svgRoot.removeAttribute('height');
    svgRoot.style.width = '100%';
    svgRoot.style.height = '100%';

    // ensure viewBox
    const vb = svgRoot.getAttribute('viewBox');
    if(vb){
      const parts = vb.split(/\s+/).map(Number);
      viewBox = { x:parts[0], y:parts[1], w:parts[2], h:parts[3] };
    }else{
      // compute after it's in DOM
      const b = svgRoot.getBBox();
      svgRoot.setAttribute('viewBox', `${b.x} ${b.y} ${b.width} ${b.height}`);
      viewBox = { x:b.x, y:b.y, w:b.width, h:b.height };
    }

    // overlay uses same viewBox
    overlay.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
    overlay.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    // add shadow filter once
    injectOverlayDefs();
  }

  function injectOverlayDefs(){
    overlay.innerHTML = `
      <defs>
        <filter id="labelShadow" x="-40%" y="-40%" width="180%" height="180%">
          <feDropShadow dx="0" dy="10" stdDeviation="10" flood-color="#000" flood-opacity="0.22"/>
        </filter>
      </defs>
    `;
  }

  function getStandNodes(){
    // Supports common exports: stands as <g id="A1"> or shape with id
    const groups = Array.from(svgRoot.querySelectorAll('g[id]'));
    const shapes = Array.from(svgRoot.querySelectorAll('path[id],rect[id],polygon[id],circle[id],ellipse[id],polyline[id],line[id]'));
    // keep only those IDs that exist in the sheet data, so we don't treat random svg ids as stands
    const exists = (id) => byId.has(id);

    const filteredGroups = groups.filter(g => exists(g.id));
    if(filteredGroups.length) return filteredGroups;

    return shapes.filter(s => exists(s.id));
  }

  function paintAll(){
    if(!svgRoot) return;

    // paint only known stands (those in the sheet)
    getStandNodes().forEach(node => {
      const id = String(node.id||'').trim();
      const isSel = (id && id === selectedId);
      const fill = isSel ? SELECTED_FILL : STAND_FILL;

      const targets = (node.tagName.toLowerCase()==='g')
        ? node.querySelectorAll('path,rect,polygon,circle,ellipse,polyline,line')
        : [node];

      targets.forEach(el => {
        el.style.fill = fill;
        el.style.fillOpacity = '1';
        el.style.stroke = 'rgba(0,0,0,0.40)';
        el.style.strokeOpacity = '0.65';
        el.style.cursor = (isPhone ? 'default' : 'pointer');
      });

      // disable taps on phone (as requested)
      if(isPhone){
        node.style.pointerEvents = 'none';
      }else{
        node.style.pointerEvents = 'auto';
      }
    });
  }

  function bindClicks(){
    if(isPhone) return; // list-only on phone

    getStandNodes().forEach(node => {
      node.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const id = String(node.id||'').trim();
        if(!id) return;
        selectStand(id);
      });
    });
  }

  function soldListItems(){
    // public list: SOLD + company not blank
    const q = String(qEl.value||'').toLowerCase().trim();

    const sold = stands
      .map(s => ({
        standId: String(s.standId||'').trim(),
        status: normalizeStatus(s.status),
        company: String(s.company||'').trim()
      }))
      .filter(s => s.standId && s.status === 'sold' && s.company);

    sold.sort((a,b) => a.company.localeCompare(b.company, undefined, {numeric:true}));

    if(!q) return sold;

    return sold.filter(s =>
      s.company.toLowerCase().includes(q) ||
      s.standId.toLowerCase().includes(q)
    );
  }

  function renderList(){
    const items = soldListItems();
    listEl.innerHTML = '';
    if(!items.length){
      listEl.innerHTML = `<div class="empty">No sold exhibitors found.</div>`;
      return;
    }
    items.forEach(s => {
      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `
        <div class="name">${escapeHtml(s.company)}</div>
        <div class="meta">Stand ${escapeHtml(s.standId)}</div>
      `;
      div.addEventListener('click', () => selectStand(s.standId));
      listEl.appendChild(div);
    });
  }

  function selectStand(id){
    const info = byId.get(id);
    if(!info) return;

    selectedId = id;

    selStand.textContent = info.standId;
    selCompany.textContent = (normalizeStatus(info.status)==='sold' && info.company) ? info.company : '';

    paintAll();
    drawOverlay(info);
  }

  function clearSelection(){
    selectedId = '';
    selStand.textContent = 'None';
    selCompany.textContent = '';
    paintAll();
    // keep defs, clear everything else
    injectOverlayDefs();
  }

  function getBBoxForStand(id){
    const node = svgRoot.querySelector('#' + CSS.escape(id));
    if(!node) return null;
    try{
      // if it's a group, bbox works across children
      return node.getBBox();
    }catch{
      return null;
    }
  }

  function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

  function drawOverlay(info){
    injectOverlayDefs();

    const bb = getBBoxForStand(info.standId);
    if(!bb || !viewBox) return;

    // anchor point on the stand (center)
    const ax = bb.x + bb.width/2;
    const ay = bb.y + bb.height/2;

    // Create label group first (so we can measure and then place)
    const g = svgEl('g', { filter:'url(#labelShadow)' });

    const titleSize = Math.max(viewBox.w / 26, 26);   // scales nicely
    const subSize   = Math.max(viewBox.w / 42, 18);

    const t1 = svgEl('text', { 'font-size': titleSize, 'font-weight':'900', 'text-anchor':'middle', fill:'#fff' });
    t1.textContent = info.standId;

    const t2 = svgEl('text', { 'font-size': subSize, 'font-weight':'800', 'text-anchor':'middle', fill:'#fff' });
    t2.textContent = (normalizeStatus(info.status)==='sold' && info.company) ? info.company : '';

    const padX = Math.max(viewBox.w * 0.012, 18);
    const padY = Math.max(viewBox.h * 0.012, 14);
    const gap  = Math.max(viewBox.h * 0.008, 10);

    // Temporarily position at 0,0 to measure
    t1.setAttribute('x', 0); t1.setAttribute('y', 0);
    t2.setAttribute('x', 0); t2.setAttribute('y', (t2.textContent ? (titleSize + gap) : 0));

    g.appendChild(t1);
    if(t2.textContent) g.appendChild(t2);
    overlay.appendChild(g);

    const gb = g.getBBox();
    const w = gb.width + padX*2;
    const h = gb.height + padY*2;

    // Candidate placements (prefer DOWN so label doesn't cover stands)
    const offset = Math.max(viewBox.w * 0.06, 60);
    const candidates = [
      { name:'down',  x: ax,             y: ay + offset },
      { name:'right', x: ax + offset*1.1,y: ay          },
      { name:'left',  x: ax - offset*1.1,y: ay          },
      { name:'up',    x: ax,             y: ay - offset }
    ];

    function score(pos){
      // keep inside viewbox
      const left = pos.x - w/2, right = pos.x + w/2;
      const top = pos.y - h/2, bottom = pos.y + h/2;

      let penalty = 0;

      // outside penalties
      if(left < viewBox.x) penalty += (viewBox.x - left) * 10;
      if(right > viewBox.x + viewBox.w) penalty += (right - (viewBox.x+viewBox.w)) * 10;
      if(top < viewBox.y) penalty += (viewBox.y - top) * 10;
      if(bottom > viewBox.y + viewBox.h) penalty += (bottom - (viewBox.y+viewBox.h)) * 10;

      // overlap with stand bbox penalty (avoid covering stand)
      const ol = Math.max(left, bb.x);
      const or = Math.min(right, bb.x + bb.width);
      const ot = Math.max(top, bb.y);
      const ob = Math.min(bottom, bb.y + bb.height);
      const ow = Math.max(0, or - ol);
      const oh = Math.max(0, ob - ot);
      const overlapArea = ow * oh;
      penalty += overlapArea * 0.02;

      // prefer down
      if(pos.name==='down') penalty -= 200;

      return penalty;
    }

    candidates.sort((a,b) => score(a) - score(b));
    let best = candidates[0];

    // Clamp the best position inside viewbox
    best = {
      x: clamp(best.x, viewBox.x + w/2 + 6, viewBox.x + viewBox.w - w/2 - 6),
      y: clamp(best.y, viewBox.y + h/2 + 6, viewBox.y + viewBox.h - h/2 - 6),
    };

    // Now draw line + dot
    const line = svgEl('line', {
      x1: ax, y1: ay,
      x2: best.x, y2: best.y,
      stroke: 'rgba(0,0,0,0.75)',
      'stroke-width': Math.max(viewBox.w * 0.002, 3),
      'stroke-linecap':'round'
    });

    const dot = svgEl('circle', {
      cx: ax, cy: ay,
      r: Math.max(viewBox.w * 0.006, 6),
      fill: 'rgba(0,0,0,0.78)'
    });

    // Label rect behind text
    const rx = Math.max(viewBox.w * 0.01, 14);

    const rect = svgEl('rect', {
      x: best.x - w/2,
      y: best.y - h/2,
      width: w,
      height: h,
      rx: rx, ry: rx,
      fill: 'rgba(229,57,53,0.95)'   // red
    });

    // Move text group into correct place
    // Place t1 baseline nicely inside rect
    const textTopY = best.y - h/2 + padY - gb.y;
    const textX = best.x - gb.x; // center

    t1.setAttribute('x', textX);
    t1.setAttribute('y', textTopY + titleSize);

    if(t2.textContent){
      t2.setAttribute('x', textX);
      t2.setAttribute('y', textTopY + titleSize + gap + subSize);
    }

    // Rebuild overlay in desired draw order
    injectOverlayDefs();
    overlay.appendChild(line);
    overlay.appendChild(dot);

    const labelGroup = svgEl('g', { filter:'url(#labelShadow)' });
    labelGroup.appendChild(rect);
    labelGroup.appendChild(t1);
    if(t2.textContent) labelGroup.appendChild(t2);
    overlay.appendChild(labelGroup);
  }

  function svgEl(tag, attrs){
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const [k,v] of Object.entries(attrs||{})){
      el.setAttribute(k, String(v));
    }
    return el;
  }

  async function sync(){
    // stands from backend
    const data = await fetchJson(API_BASE + '/stands?ts=' + Date.now());
    stands = Array.isArray(data) ? data : [];

    byId = new Map(
      stands.map(s => [String(s.standId||'').trim(), {
        standId: String(s.standId||'').trim(),
        status: normalizeStatus(s.status),
        company: String(s.company||'').trim()
      }]).filter(([id]) => id)
    );

    renderList();
    paintAll();
    bindClicks();

    // keep selection if possible
    if(selectedId && byId.has(selectedId)){
      drawOverlay(byId.get(selectedId));
    }else{
      clearSelection();
    }

    elUpdated.textContent = 'Updated: ' + new Date().toLocaleTimeString();
    setStatus('Ready', true);
  }

  // Simple PDF export: saves a PNG of the plan (including label) into a PDF using jsPDF
  async function ensureJsPdf(){
    if(window.jspdf && window.jspdf.jsPDF) return;
    await new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
      s.onload = resolve;
      s.onerror = () => reject(new Error('Failed to load PDF library'));
      document.head.appendChild(s);
    });
  }

  async function exportPdf(){
    btnPdf.disabled = true;
    try{
      setStatus('Preparing PDF…', true);

      // Create a combined SVG (base plan + overlay)
      const base = svgRoot.cloneNode(true);
      const over = overlay.cloneNode(true);

      // Remove overlay defs duplicates etc not critical
      // Put overlay content into base
      const baseVb = base.getAttribute('viewBox') || `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`;
      base.setAttribute('viewBox', baseVb);
      base.removeAttribute('width');
      base.removeAttribute('height');

      // Wrap overlay children (skip outer <svg>)
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      Array.from(over.childNodes).forEach(n => g.appendChild(n.cloneNode(true)));
      base.appendChild(g);

      // Serialize to image
      const svgText = new XMLSerializer().serializeToString(base);
      const svgBlob = new Blob([svgText], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);

      const img = new Image();
      img.crossOrigin = 'anonymous';
      await new Promise((resolve,reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });

      // draw to canvas at decent resolution
      const canvas = document.createElement('canvas');
      const scale = 2.0;
      canvas.width = Math.round(1400 * scale);
      canvas.height = Math.round(800 * scale);

      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // fit image to canvas
      const iw = img.width, ih = img.height;
      const r = Math.min(canvas.width/iw, canvas.height/ih);
      const dw = iw * r, dh = ih * r;
      const dx = (canvas.width - dw)/2;
      const dy = (canvas.height - dh)/2;
      ctx.drawImage(img, dx, dy, dw, dh);

      URL.revokeObjectURL(url);

      await ensureJsPdf();
      const { jsPDF } = window.jspdf;

      const pdf = new jsPDF({orientation:'landscape', unit:'pt', format:'a4'});
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();

      const png = canvas.toDataURL('image/png', 1.0);

      // fit PNG to page
      const pr = Math.min(pageW / canvas.width, pageH / canvas.height);
      const pw = canvas.width * pr;
      const ph = canvas.height * pr;
      const px = (pageW - pw)/2;
      const py = (pageH - ph)/2;

      pdf.addImage(png, 'PNG', px, py, pw, ph);
      pdf.save((elTitle.textContent || 'floorplan').replace(/\s+/g,'-').toLowerCase() + '.pdf');

      setStatus('Ready', true);
    }catch(e){
      console.error(e);
      setStatus('PDF error: ' + (e.message || e), false);
    }finally{
      btnPdf.disabled = false;
    }
  }

  btnClear.addEventListener('click', clearSelection);
  qEl.addEventListener('input', renderList);
  btnPdf.addEventListener('click', exportPdf);

  (async () => {
    try{
      setStatus('Loading…', false);
      await loadSettings();
      await loadSvg();
      await sync();
    }catch(e){
      console.error(e);
      setStatus('Load error: ' + (e.message || e), false);
    }
  })();

})();
</script>
</body>
</html>
