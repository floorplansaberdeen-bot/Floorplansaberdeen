<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Exhibition Floorplan</title>
<style>
  :root {
    --card-border: rgba(0,0,0,.12);
    --muted: rgba(0,0,0,.62);
    --main-fill: rgba(213, 109, 50, 0.75);
    --sold-fill: #e53935;
    --selected-fill: #e53935;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    background: #fff;
    color: #111;
  }
  header {
    padding: 18px 16px 10px;
    display:flex;
    gap:14px;
    align-items:flex-start;
    justify-content:space-between;
    flex-wrap:wrap;
  }
  .titleWrap h1 {
    margin: 0;
    font-size: 34px;
    line-height: 1.02;
  }
  .sub {
    margin-top: 6px;
    color: var(--muted);
    font-size: 14px;
  }
  .status {
    margin-top: 6px;
    font-weight: 700;
    color: #1b5e20;
    font-size: 16px;
  }
  .btnRow {
    display:flex; gap:10px; align-items:center;
  }
  button {
    border: 1px solid var(--card-border);
    background: #fff;
    border-radius: 14px;
    padding: 12px 16px;
    font-weight: 700;
    cursor: pointer;
  }
  button:disabled { opacity:.45; cursor:not-allowed; }
  main {
    display:grid;
    grid-template-columns: 1.4fr 520px;
    gap: 16px;
    padding: 0 16px 16px;
  }
  @media (max-width: 1000px) {
    main {
      grid-template-columns: 1fr;
    }
  }
  .card {
    border: 1px solid var(--card-border);
    border-radius: 16px;
    background:#fff;
    overflow:hidden;
  }
  .cardHead {
    padding: 14px 14px 0;
    font-weight: 800;
  }
  .planCard {
    position: relative;
  }
  .planViewport {
    position: relative;
    height: min(560px, 62vh);
    padding: 14px;
  }
  @media (max-width: 700px) {
    .planViewport {
      height: 320px;
      padding: 12px;
    }
    header .titleWrap h1 { font-size: 40px; }
  }
  /* Make plan "sticky" on phone so list scrolls underneath */
  @media (max-width: 1000px) {
    .planCard {
      position: sticky;
      top: 0;
      z-index: 10;
      background:#fff;
    }
  }
  .svgHost {
    position:absolute;
    left: 14px; top: 14px; right: 14px; bottom: 14px;
    border-radius: 14px;
  }
  .svgHost svg { width:100%; height:100%; display:block; }
  /* overlay svg uses pixel coords via dynamic viewBox */
  #overlaySvg {
    position:absolute;
    left: 14px; top: 14px; right: 14px; bottom: 14px;
    pointer-events:none;
  }
  .callout {
    position:absolute;
    min-width: 180px;
    max-width: 320px;
    padding: 14px 18px;
    border-radius: 18px;
    background: var(--selected-fill);
    color: #fff;
    box-shadow: 0 12px 24px rgba(0,0,0,.18);
    pointer-events:none;
    text-align:center;
  }
  .callout .stand {
    font-weight: 900;
    font-size: 34px;
    letter-spacing: .5px;
    line-height: 1;
  }
  .callout .company {
    margin-top: 6px;
    font-weight: 800;
    font-size: 18px;
    opacity: .98;
    line-height: 1.15;
  }
  @media (max-width: 700px) {
    .callout {
      padding: 12px 14px;
      min-width: 150px;
      border-radius: 16px;
    }
    .callout .stand { font-size: 30px; }
    .callout .company { font-size: 16px; }
  }
  /* right column */
  .side {
    display:flex;
    flex-direction:column;
    gap: 16px;
  }
  .pad {
    padding: 14px;
  }
  .selectedBig {
    font-size: 44px;
    font-weight: 900;
    line-height: 1;
    margin: 6px 0 0;
  }
  .muted { color: var(--muted); }
  .search {
    width:100%;
    border: 1px solid var(--card-border);
    border-radius: 12px;
    padding: 12px 12px;
    font-size: 16px;
  }
  .list {
    max-height: 54vh;
    overflow:auto;
    padding-bottom: 90px; /* iOS browser bar */
  }
  @media (max-width: 1000px) {
    .list { max-height: none; }
  }
  .row {
    padding: 12px 14px;
    border-top: 1px solid rgba(0,0,0,.08);
    cursor:pointer;
  }
  .row:hover { background: rgba(0,0,0,.03); }
  .row .nm { font-weight: 900; font-size: 20px; }
  .row .st { color: var(--muted); margin-top: 2px; }
  .row.active {
    background: rgba(229,57,53,.08);
  }
  /* Ensure plan tapping is disabled on touch devices (prevents freezes) */
  @media (hover: none) and (pointer: coarse) {
    .svgHost { pointer-events:none; }
  }
</style>
</head>
<body>
<header>
  <div class="titleWrap">
    <h1 id="eventTitle">Loading…</h1>
    <div class="sub">Updated: <span id="updatedAt">—</span></div>
    <div class="status" id="readyState">Loading…</div>
  </div>
  <div class="btnRow">
    <button id="btnPdf">Export PDF</button>
    <button id="btnClear">Clear selection</button>
  </div>
</header>

<main>
  <section class="card planCard">
    <div class="planViewport" id="planViewport">
      <div class="svgHost" id="svgHost"></div>

      <!-- overlay in pixel units -->
      <svg id="overlaySvg" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <line id="olLine" x1="0" y1="0" x2="0" y2="0" stroke="rgba(0,0,0,.65)" stroke-width="4" stroke-linecap="round"/>
        <circle id="olDot" cx="0" cy="0" r="7" fill="rgba(0,0,0,.78)"/>
      </svg>

      <div class="callout" id="callout" style="display:none">
        <div class="stand" id="coStand"></div>
        <div class="company" id="coCompany"></div>
      </div>
    </div>
  </section>

  <aside class="side">
    <section class="card">
      <div class="pad">
        <div style="font-weight:900;">Selected exhibitor</div>
        <div class="selectedBig" id="selStand">None</div>
        <div style="font-size:22px; font-weight:900; margin-top:6px;" id="selCompany"></div>
        <div class="muted" style="margin-top:10px;">
          Desktop: click a stand or choose from the list.<br/>
          Phone: use the list (stand tapping is disabled).
        </div>
      </div>
    </section>

    <section class="card">
      <div class="pad">
        <div style="font-weight:900; margin-bottom:10px;">Sold exhibitors</div>
        <input class="search" id="search" placeholder="Search company or stand…"/>
      </div>
      <div class="list" id="list"></div>
    </section>

    <section class="card">
      <div class="pad">
        <div style="font-weight:900;">Help</div>
        <div class="muted" style="margin-top:6px;">
          Selecting an exhibitor makes their stand red with a label + line.
        </div>
      </div>
    </section>
  </aside>
</main>

<script>
(() => {
  const API_BASE = "https://floorplansaberdeen.floorplansaberdeen.workers.dev";
  const SVG_URL = "event_plan.svg";

  const MAIN_FILL = getComputedStyle(document.documentElement).getPropertyValue('--main-fill').trim();
  const SOLD_FILL = getComputedStyle(document.documentElement).getPropertyValue('--sold-fill').trim();
  const SELECT_FILL = getComputedStyle(document.documentElement).getPropertyValue('--selected-fill').trim();

  const elTitle = document.getElementById('eventTitle');
  const elUpdated = document.getElementById('updatedAt');
  const elReady = document.getElementById('readyState');

  const svgHost = document.getElementById('svgHost');
  const planViewport = document.getElementById('planViewport');

  const overlaySvg = document.getElementById('overlaySvg');
  const olLine = document.getElementById('olLine');
  const olDot = document.getElementById('olDot');

  const callout = document.getElementById('callout');
  const coStand = document.getElementById('coStand');
  const coCompany = document.getElementById('coCompany');

  const selStand = document.getElementById('selStand');
  const selCompany = document.getElementById('selCompany');

  const listEl = document.getElementById('list');
  const searchEl = document.getElementById('search');

  const btnPdf = document.getElementById('btnPdf');
  const btnClear = document.getElementById('btnClear');

  let svgRoot = null;
  let byId = new Map(); // standId -> {standId,status,company}
  let selectedId = '';
  let lastDataTs = 0;

  function normalizeStatus(s) {
    s = String(s||'').toLowerCase().trim();
    if (s === 'sold' || s === 'booked') return 'sold';
    return 'available';
  }

  async function fetchJson(url) {
    const r = await fetch(url, {cache:'no-store'});
    if (!r.ok) throw new Error('HTTP '+r.status);
    return await r.json();
  }

  async function loadSvg() {
    const r = await fetch(SVG_URL + '?v=' + Date.now(), {cache:'no-store'});
    if (!r.ok) throw new Error('Failed to load SVG');
    const txt = await r.text();
    const doc = new DOMParser().parseFromString(txt, 'image/svg+xml');
    const svg = doc.documentElement;

    svg.removeAttribute('width'); svg.removeAttribute('height');
    svg.style.width = '100%'; svg.style.height = '100%';
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

    // Make clickable only on desktop
    svg.querySelectorAll('*').forEach(el=> {
      el.style.cursor = 'pointer';
    });

    svgHost.innerHTML = '';
    svgHost.appendChild(svg);
    svgRoot = svg;

    // Click handler (desktop only; on touch devices we disable pointer events via CSS)
    svgRoot.addEventListener('click', (e) => {
      const t = e.target.closest('[id]');
      if (!t) return;
      const id = t.id;
      if (!byId.has(id)) return;
      selectStand(id, true);
    });

    // Ensure overlay uses pixel units: set viewBox to match overlay size.
    syncOverlayViewBox();
    new ResizeObserver(syncOverlayViewBox).observe(planViewport);
  }

  function syncOverlayViewBox() {
    const r = overlaySvg.getBoundingClientRect();
    overlaySvg.setAttribute('viewBox', `0 0 ${Math.max(1, Math.round(r.width))} ${Math.max(1, Math.round(r.height))}`);
  }

  function getNodeCenterInOverlayPx(node) {
    const vr = planViewport.getBoundingClientRect();
    const nr = node.getBoundingClientRect();
    const cx = (nr.left + nr.right)/2 - vr.left - 14; // subtract padding because overlaySvg is inset by 14px
    const cy = (nr.top + nr.bottom)/2 - vr.top - 14;
    return {x: cx, y: cy};
  }

  function colorAllStands() {
    if (!svgRoot) return;
    svgRoot.querySelectorAll('[id]').forEach(el => {
      const id = el.id;
      if (!byId.has(id)) return;
      // all stands main color, only selected is red
      const fill = (id === selectedId) ? SELECT_FILL : MAIN_FILL;
      try {
        el.style.fill = fill;
        el.style.fillOpacity = '';
      } catch {}
    });
  }

  function buildSoldListRows() {
    const q = (searchEl.value || '').trim().toLowerCase();
    const sold = Array.from(byId.values())
      .filter(r => normalizeStatus(r.status) === 'sold')
      .filter(r => {
        const a = (r.company || '').toLowerCase();
        const b = (r.standId || '').toLowerCase();
        return !q || a.includes(q) || b.includes(q);
      })
      .sort((a,b)=> (a.company||'').localeCompare(b.company||'') || a.standId.localeCompare(b.standId));

    listEl.innerHTML = '';
    for (const r of sold) {
      const row = document.createElement('div');
      row.className = 'row' + (r.standId === selectedId ? ' active' : '');
      row.dataset.id = r.standId;
      row.innerHTML = `
        <div class="nm">${escapeHtml(r.company || '(No company)')}</div>
        <div class="st">Stand ${escapeHtml(r.standId)}</div>
      `;
      row.addEventListener('click', () => selectStand(r.standId, true));
      listEl.appendChild(row);
    }
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  function clearOverlay() {
    callout.style.display = 'none';
    olLine.style.display = 'none';
    olDot.style.display = 'none';
  }

  function placeCallout(node, standId, company) {
    if (!node) return clearOverlay();
    syncOverlayViewBox();

    const vp = planViewport.getBoundingClientRect();
    const svgR = svgRoot.getBoundingClientRect();

    // Where the stand is (overlay px)
    const anchor = getNodeCenterInOverlayPx(node);

    // Size estimate for callout (after setting text)
    coStand.textContent = standId;
    coCompany.textContent = company || '';
    callout.style.display = 'block';

    // Force layout to get size
    const cw = callout.offsetWidth;
    const ch = callout.offsetHeight;

    // Candidate placements OUTSIDE the SVG drawing rect so it doesn't cover stands:
    // below the SVG, above the SVG, left of SVG, right of SVG (clamped to viewport)
    const inset = 12;
    const overlayW = overlaySvg.getBoundingClientRect().width;
    const overlayH = overlaySvg.getBoundingClientRect().height;

    // svg box in overlay coords
    const svgLeft = svgR.left - vp.left - 14;
    const svgTop = svgR.top - vp.top - 14;
    const svgRight = svgR.right - vp.left - 14;
    const svgBottom = svgR.bottom - vp.top - 14;

    const candidates = [];

    // below
    candidates.push({
      x: clamp(anchor.x - cw/2, inset, overlayW - cw - inset),
      y: clamp(svgBottom + 12, inset, overlayH - ch - inset),
      score: 0
    });
    // above
    candidates.push({
      x: clamp(anchor.x - cw/2, inset, overlayW - cw - inset),
      y: clamp(svgTop - ch - 12, inset, overlayH - ch - inset),
      score: 0
    });
    // left
    candidates.push({
      x: clamp(svgLeft - cw - 12, inset, overlayW - cw - inset),
      y: clamp(anchor.y - ch/2, inset, overlayH - ch - inset),
      score: 0
    });
    // right
    candidates.push({
      x: clamp(svgRight + 12, inset, overlayW - cw - inset),
      y: clamp(anchor.y - ch/2, inset, overlayH - ch - inset),
      score: 0
    });

    // Score: prefer positions that are truly outside svg bounds.
    for (const c of candidates) {
      const insideX = (c.x + cw/2) >= svgLeft && (c.x + cw/2) <= svgRight;
      const insideY = (c.y + ch/2) >= svgTop && (c.y + ch/2) <= svgBottom;
      c.score = (insideX && insideY) ? 10 : 0; // penalize covering the svg
      // prefer shorter line
      const ax = c.x + cw/2, ay = c.y + ch/2;
      const dx = ax - anchor.x, dy = ay - anchor.y;
      c.score += Math.sqrt(dx*dx + dy*dy) / 80;
    }
    candidates.sort((a,b)=>a.score-b.score);
    const best = candidates[0];

    callout.style.left = `${Math.round(best.x)}px`;
    callout.style.top = `${Math.round(best.y)}px`;

    // Connect line to callout edge (closest point on callout box)
    const cx = best.x + cw/2;
    const cy = best.y + ch/2;
    const p = closestPointOnRect(anchor.x, anchor.y, best.x, best.y, cw, ch);

    olLine.style.display = '';
    olDot.style.display = '';

    olLine.setAttribute('x1', p.x);
    olLine.setAttribute('y1', p.y);
    olLine.setAttribute('x2', anchor.x);
    olLine.setAttribute('y2', anchor.y);

    olDot.setAttribute('cx', anchor.x);
    olDot.setAttribute('cy', anchor.y);
    olDot.setAttribute('r', '7');
  }

  function closestPointOnRect(px, py, rx, ry, rw, rh) {
    // clamp to rect then nudge to edge
    const cx = clamp(px, rx, rx+rw);
    const cy = clamp(py, ry, ry+rh);

    // If inside, project to nearest edge
    if (cx > rx && cx < rx+rw && cy > ry && cy < ry+rh) {
      const dl = Math.abs(cx-rx);
      const dr = Math.abs(rx+rw-cx);
      const dt = Math.abs(cy-ry);
      const db = Math.abs(ry+rh-cy);
      const m = Math.min(dl,dr,dt,db);
      if (m===dl) return {x: rx, y: cy};
      if (m===dr) return {x: rx+rw, y: cy};
      if (m===dt) return {x: cx, y: ry};
      return {x: cx, y: ry+rh};
    }
    // outside: use clamped
    return {x: cx, y: cy};
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function setSelectedPanel(r) {
    if (!r) {
      selStand.textContent = 'None';
      selCompany.textContent = '';
      return;
    }
    selStand.textContent = r.standId;
    selCompany.textContent = r.company || '';
  }

  function selectStand(id, scrollIntoView) {
    selectedId = id || '';
    colorAllStands();
    buildSoldListRows();

    const r = byId.get(selectedId);
    setSelectedPanel(r);

    if (!selectedId) {
      clearOverlay();
      return;
    }

    const node = svgRoot && svgRoot.querySelector('#' + CSS.escape(selectedId));
    if (node) {
      placeCallout(node, r.standId, r.company || '');
      if (scrollIntoView) {
        const row = listEl.querySelector(`[data-id="${CSS.escape(selectedId)}"]`);
        if (row) row.scrollIntoView({block:'center'});
      }
    } else {
      clearOverlay();
    }
  }

  async function syncData(forceTitle=false) {
    const data = await fetchJson(API_BASE + '/stands?ts=' + Date.now());
    byId = new Map((Array.isArray(data)?data:[]).map(x => {
      const standId = String(x.standId||'').trim();
      return [standId, {
        standId,
        status: normalizeStatus(x.status),
        company: String(x.company||'').trim()
      }];
    }));
    lastDataTs = Date.now();

    // Title from server (optional)
    if (forceTitle) {
      try {
        const meta = await fetchJson(API_BASE + '/meta?ts=' + Date.now());
        if (meta && meta.eventName) elTitle.textContent = meta.eventName;
      } catch {
        elTitle.textContent = 'Getaway Show 2026';
      }
    }

    elUpdated.textContent = new Date().toLocaleTimeString();
    elReady.textContent = 'Ready ✅';

    colorAllStands();
    buildSoldListRows();

    if (selectedId) {
      const r = byId.get(selectedId);
      if (r) {
        const node = svgRoot.querySelector('#' + CSS.escape(selectedId));
        if (node) placeCallout(node, r.standId, r.company||'');
      }
    }
  }

  // PDF export (simple: opens print dialog with raster)
  btnPdf.addEventListener('click', () => {
    window.print();
  });

  btnClear.addEventListener('click', () => {
    selectedId = '';
    setSelectedPanel(null);
    buildSoldListRows();
    colorAllStands();
    clearOverlay();
  });

  searchEl.addEventListener('input', () => buildSoldListRows());

  // keep overlay accurate on scroll/resize
  window.addEventListener('resize', () => {
    syncOverlayViewBox();
    if (selectedId && svgRoot) {
      const node = svgRoot.querySelector('#' + CSS.escape(selectedId));
      const r = byId.get(selectedId);
      if (node && r) placeCallout(node, r.standId, r.company||'');
    }
  });

  window.addEventListener('scroll', () => {
    if (!selectedId || !svgRoot) return;
    const node = svgRoot.querySelector('#' + CSS.escape(selectedId));
    const r = byId.get(selectedId);
    if (node && r) placeCallout(node, r.standId, r.company||'');
  }, {passive:true});

  (async () => {
    try {
      elReady.textContent = 'Loading…';
      await loadSvg();
      await syncData(true);
      // refresh periodically
      setInterval(() => syncData(false).catch(()=>{}), 15000);
    } catch (e) {
      console.error(e);
      elReady.textContent = 'Error loading';
      elTitle.textContent = 'Exhibition Floorplan';
    }
  })();
})();
</script>
</body>
</html>
