<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Floorplan Admin</title>
  <style>
    :root{
      --bg:#ffffff;
      --card:#ffffff;
      --border:#e9e9e9;
      --text:#111;
      --muted:#666;
      --avail: rgba(213,109,50,0.75);
      --sold:#e63b3b;
      --shadow: 0 12px 30px rgba(0,0,0,.12);
      --dot: 10px; /* dot DIAMETER (match public) */
      --line: rgba(0,0,0,.70);
      --safe: env(safe-area-inset-bottom, 0px);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:var(--bg); color:var(--text);
    }
    header{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border-bottom:1px solid var(--border);
      flex-wrap:wrap;
      background:#fff;
    }
    header .title{ font-weight:900; font-size:18px; }
    header .tools{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header input{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      min-width: 260px;
      font-weight:700;
    }
    button{
      border:1px solid var(--border);
      background:#fff;
      padding:10px 14px;
      border-radius:12px;
      font-weight:800;
      cursor:pointer;
    }
    button.primary{
      background:#16a34a;
      border-color:#16a34a;
      color:#fff;
    }
    button.primary:hover{ filter: brightness(0.95); }
    button.primary:active{ filter: brightness(0.9); }
    button.danger{ border-color:#ffd0d0; background:#fff5f5; }

    button.ghost{
      border:1px solid var(--border);
      background:#fafafa;
      color:#444;
      font-weight:900;
    }
    button.ghost:disabled{ opacity:.45; cursor:not-allowed; }

    button.danger.solid{
      background:#e63b3b;
      border-color:#e63b3b;
      color:#fff;
    }
    button.danger.solid:hover{ filter: brightness(0.95); }
    button.danger.solid:active{ filter: brightness(0.9); }
    button:disabled{ opacity:.45; cursor:not-allowed; }

    main{
      padding:16px;
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap:16px;
      align-items:start;
    }
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow: 0 1px 0 rgba(0,0,0,.02);
    }
    .cardHead{
      padding:10px 12px;
      font-weight:900;
      border-bottom:1px solid var(--border);
    }
    .planCard{ overflow:hidden; }
    .planBody{ padding:12px; }

    /* ===== Plan + Label bay + Callout overlay ===== */
    .planStack{ position:relative; border-radius:14px; overflow:hidden; background:#fff; }
    .planWrap{
      position:relative;
      border-radius:14px;
      overflow:hidden;
      background:#fff;
      min-height:420px;
    }
    .svgHost{ width:100%; height:auto; display:block; pointer-events:auto; }

    /* Overlay spans BOTH plan + label bay */
    .calloutSvg{
      position:absolute; left:0; top:0;
      width:100%; height:100%;
      pointer-events:none;
    }

    .labelBay{
      background:#fff;
      border-top:1px solid var(--border);
      padding:12px;
      min-height:72px;
    }
    .lozenge{
      display:inline-block;
      background:#fff;
      border-radius:999px;
      padding:12px 16px;
      box-shadow: var(--shadow);
      border:1px solid rgba(0,0,0,.08);
      max-width: 340px;
    }
    .lozStand{ font-size:28px; font-weight:900; line-height:1.1; }
    .lozCompany{ margin-top:4px; font-size:16px; font-weight:800; opacity:.9; }

    .legend{ padding:10px 12px; display:flex; gap:10px; align-items:center; border-top:1px solid var(--border); }
    .pill{ display:flex; align-items:center; gap:8px; border:1px solid var(--border); padding:6px 10px; border-radius:999px; font-weight:800; font-size:13px; }
    .sw{ width:10px; height:10px; border-radius:999px; display:inline-block; }

    .zoomCard .cardHead{ display:flex; justify-content:space-between; }
    .zoomBody{ padding:12px; }
    .zoomWrap{
      position:relative;
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      min-height:260px;
      background:#fff;
    }
    .zoomSvgHost{ width:100%; height:auto; display:block; }
    .zoomRing{
      position:absolute;
      border:4px solid rgba(0,0,0,.75);
      border-radius:999px;
      pointer-events:none;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      display:none;
    }
    .hint{ color:var(--muted); font-size:13px; padding:10px 12px 12px; }

    .side{ padding:12px; display:flex; flex-direction:column; gap:12px; }
    .formRow{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .side label{ display:block; font-weight:800; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .side input, .side select{
      width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      font-weight:700;
    }
    .btnRow{ display:flex; gap:10px; }
    .btnRow button{ flex:1; }

    .tableWrap{ border:1px solid var(--border); border-radius:14px; overflow:hidden; }
    .tableTools{ padding:10px; display:flex; gap:10px; align-items:center; }
    .tableTools input{
      flex:1; padding:10px 12px; border-radius:12px; border:1px solid var(--border);
      font-weight:800;
    }
    table{ width:100%; border-collapse:collapse; font-size:13px; }
    th, td{ padding:10px 10px; border-top:1px solid #f0f0f0; text-align:left; }
    th{ background:#fafafa; border-top:none; font-size:12px; color:var(--muted); }
    tr.active{ background:#f5f8ff; outline:2px solid #c9d5ff; outline-offset:-2px; }
    .badge{ display:inline-flex; align-items:center; padding:3px 8px; border-radius:999px; font-weight:900; font-size:12px; border:1px solid var(--border); }
    .bSold{ color:#b40000; border-color:#ffd0d0; background:#fff5f5; }
    .bAvail{ color:#6b3a0f; border-color:#f2dfcf; background:#fff7f0; }

    .toast{
      position:fixed;
      left:16px; right:16px; bottom:16px;
      background:#111; color:#fff;
      padding:12px 14px;
      border-radius:14px;
      display:none;
      z-index:9999;
      box-shadow: var(--shadow);
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .toast .msg{ font-weight:800; font-size:13px; line-height:1.3; }
    .toast .actions{ display:flex; gap:10px; }
    .toast button{ background:#fff; }

    
    
    @media (min-width: 981px){
      /* Keep the whole right panel visible; only the stands list area scrolls */
      .side{
        position: sticky;
        top: 12px;
        max-height: calc(100vh - 24px);
        overflow: hidden;          /* IMPORTANT: prevent whole panel scrolling */
      }
      .standsCard{
        display:flex;
        flex-direction:column;
        min-height: 0;             /* allow inner scrolling */
        flex: 1;
      }
      .standsCard .tableWrap{
        flex: 1;
        overflow: auto;            /* ONLY the list scrolls */
      }
    }

    }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }
    @media (max-width: 640px){
      main{ grid-template-columns: 1fr; padding:12px; gap:12px; }
      header input{ min-width: 180px; width: 100%; }
      .planWrap{ min-height: 260px; }

      /* Reduce empty white space under the plan on phone */
      .planBody{ padding:8px; }
      .planWrap{ min-height: 0 !important; }
      .planStack{ padding-bottom: 0; }
      .labelBay{ min-height: 0; padding:8px; }

      /* When nothing is selected, collapse the label bay entirely (Safari-safe, no :has) */
      .planStack.noSel .labelBay{
        padding:0;
        min-height:0;
        border-top:0;
      }

      /* Hide zoom on phone */
      .zoomCard{ display:none; }

      /* Pin plan + selected stand at top */
      .planCard{
        position: sticky;
        top: 0;
        z-index: 30;
        background: var(--bg);
      }
      #selectedCard{
        position: sticky;
        top: 330px; /* will be corrected in JS on load/resize */
        z-index: 29;
        background: var(--bg);
      }

      /* Make the stands list area scroll under pinned panels */
      #standsCard{ max-height: none; }
      #tableWrap{
        max-height: 55vh; /* will be corrected in JS on load/resize */
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: calc(18px + var(--safe));
      }

      /* Extra safe-area padding so browser bar doesn’t block last row */
      .tableWrap{ padding-bottom: calc(18px + var(--safe)); }
    }

  .progressOverlay{
  position:fixed; inset:0;
  background: rgba(255,255,255,.75);
  backdrop-filter: blur(2px);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1000;
  padding:20px;
}
.progressCard{
  background:#fff;
  border:1px solid var(--border);
  border-radius:16px;
  box-shadow: var(--shadow);
  padding:14px 16px;
  width:min(420px, 100%);
}
.progressTitle{ font-weight:950; font-size:14px; }
.progressMsg{ margin-top:6px; color:var(--muted); font-weight:800; font-size:13px; line-height:1.35; }
.progressBar{
  margin-top:12px;
  height:10px;
  border-radius:999px;
  background:#f2f2f2;
  overflow:hidden;
  border:1px solid rgba(0,0,0,.06);
}
.progressBar > div{
  height:100%;
  width:0%;
  background:#111;
  border-radius:999px;
  transition: width .15s ease;
}
  </style>
</head>
<body>
  <header>
    <div class="title">Floorplan Admin</div>
    <div class="tools">
      <div style="color:var(--muted); font-weight:800;">Synced: <span id="syncedAt">—</span></div>
      <div style="display:flex; gap:10px; align-items:center;">
        <div style="font-weight:900;">Event name</div>
        <input id="eventName" placeholder="New Event" />
        <button id="setEventBtn" class="primary" title="Save event name">Set</button>
      </div>
      <button id="pauseBtn">Pause sync</button>
      <button id="exportBtn">Export CSV</button>
      <button id="importBtn">Import CSV</button>
      <button class="danger" id="resetBtn">Reset all</button>
    </div>
  </header>

  <main>
    <section class="card planCard">
      <div class="cardHead">Plan</div>
      <div class="planBody">
        <div class="planStack noSel" id="planStack">
          <div class="planWrap" id="planWrap">
            <div id="svgHost" class="svgHost"></div>
          </div>

          <div class="labelBay" id="labelBay">
            <div class="lozenge" id="lozenge" style="display:none;">
              <div class="lozStand" id="lozStand">—</div>
              <div class="lozCompany" id="lozCompany" style="display:none;"></div>
            </div>
          </div>

          <!-- ONE overlay only, spanning plan + label bay -->
          <svg class="calloutSvg" id="calloutSvg" aria-hidden="true"></svg>
        </div>
      </div>

      <div class="legend">
        <div class="pill"><span class="sw" style="background:var(--sold)"></span>Sold</div>
        <div class="pill"><span class="sw" style="background:var(--avail)"></span>Available</div>
      </div>

      <section class="card zoomCard" style="margin:12px;">
        <div class="cardHead">Zoom</div>
        <div class="zoomBody">
          <div class="zoomWrap" id="zoomWrap">
            <div id="zoomSvgHost" class="zoomSvgHost"></div>
            <div class="zoomRing" id="zoomRing"></div>
          </div>
          <div class="hint">Select a stand to zoom in.</div>
        </div>
      </section>
    </section>

    <aside class="card side">
      <div class="card" id="selectedCard" style="border:1px solid var(--border); border-radius:14px; padding:12px;">
        <div style="font-weight:900; margin-bottom:10px;">Selected Stand</div>

        <div style="margin-bottom:10px;">
          <label>Stand ID</label>
          <input id="standId" disabled />
        </div>

        <div class="formRow" style="margin-bottom:10px;">
          <div>
            <label>Status</label>
            <select id="status">
              <option value="available">Available</option>
              <option value="sold">Sold</option>
            </select>
          </div>
          <div>
            <label>Company (sold only)</label>
            <input id="company" placeholder="Company name…" />
          </div>
        </div>

        <div class="btnRow">
          <button id="saveBtn" class="primary">Save</button>
          <button id="markAvailBtn" class="danger solid">Mark Available</button>
        </div>

        <div class="btnRow" style="margin-top:10px;">
          <button id="undoBtn" class="ghost" disabled>Undo last change</button>
        </div>

        <div class="hint" style="padding:10px 0 0;">Click a stand on the plan or in the list to edit.</div>
      </div>

      <div class="card standsCard" style="border:1px solid var(--border); border-radius:14px;">
        <div class="cardHead">Stands</div>
        <div class="tableTools">
          <input id="search" placeholder="Search stand or company…" />
          <select id="filter" style="width:120px; padding:10px 12px; border-radius:12px; border:1px solid var(--border); font-weight:800;">
            <option value="all">All</option>
            <option value="sold">Sold</option>
            <option value="available">Available</option>
          </select>
        </div>
        <div style="padding:0 12px 10px; color:var(--muted); font-weight:800;"><span id="count">0</span> / <span id="total">0</span></div>
        <div class="tableWrap" id="tableWrap">
          <table>
            <thead>
              <tr><th style="width:90px;">Stand</th><th style="width:120px;">Status</th><th>Company</th></tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
      </div>
    </aside>
  </main>

<div class="progressOverlay" id="progressOverlay" aria-hidden="true">
  <div class="progressCard">
    <div class="progressTitle" id="progressTitle">Updating…</div>
    <div class="progressMsg" id="progressMsg">Please keep this tab open.</div>
    <div class="progressBar"><div id="progressBarFill"></div></div>
  </div>
</div>

  <div class="toast" id="toast">
    <div class="msg" id="toastMsg">Can't reach the backend right now. If Cloudflare is down, you can paste your Google Apps Script Web App URL instead.</div>
    <div class="actions">
      <button id="setBackendBtn">Set backend URL</button>
      <button id="hideToastBtn">Hide</button>
    </div>
  </div>

<script>
(() => {

  // Optional: lock admin behind a URL-only secret.
  // 1) Set ADMIN_URL_KEY to a hard-to-guess string.
  // 2) Visit: admin.html?k=YOUR_KEY
  const ADMIN_URL_KEY = "getaway_admin_abdn001";
  const ADMIN_KEY_PARAM = "k";
  if (ADMIN_URL_KEY !== "CHANGE_ME") {
    const u = new URL(location.href);
    if ((u.searchParams.get(ADMIN_KEY_PARAM) || "") !== ADMIN_URL_KEY) {
      document.body.innerHTML = `
        <div style="padding:24px;font-family:ui-sans-serif,system-ui;">
          <h1 style="margin:0 0 8px 0;">Floorplan Admin</h1>
          <p style="margin:0 0 10px 0;">This page is locked. Add <code>?k=…</code> to the URL.</p>
        </div>`;
      return;
    }
  }

  const DEFAULT_BACKEND = "https://floorplansaberdeen.floorplansaberdeen.workers.dev";
  const BACKEND_KEY = "floorplan_backend_url";
  const SVG_URL = new URL("./event_plan.svg", window.location.href).href;

  const el = (id) => document.getElementById(id);

  const planWrap = el("planWrap");
  const svgHost = el("svgHost");
  const zoomWrap = el("zoomWrap");
  const zoomSvgHost = el("zoomSvgHost");
  const zoomRing = el("zoomRing");

  const planStack = el("planStack");
  const calloutSvg = el("calloutSvg");
  const lozenge = el("lozenge");
  const lozStand = el("lozStand");
  const lozCompany = el("lozCompany");

  const tbody = el("tbody");
  const searchEl = el("search");
  const filterEl = el("filter");
  const countEl = el("count");
  const totalEl = el("total");

  const standIdEl = el("standId");
  const statusEl = el("status");
  const companyEl = el("company");
  const saveBtn = el("saveBtn");
  const markAvailBtn = el("markAvailBtn");
  const undoBtn = el("undoBtn");

  const toast = el("toast");
  const toastMsg = el("toastMsg");
  const toastActions = toast ? toast.querySelector(".actions") : null;
  const progressOverlay = el("progressOverlay");
  const progressTitle = el("progressTitle");
  const progressMsg = el("progressMsg");
  const progressBarFill = el("progressBarFill");
  const setBackendBtn = el("setBackendBtn");
  const hideToastBtn = el("hideToastBtn");
  const syncedAt = el("syncedAt");

  const eventNameEl = el("eventName");
  const setEventBtn = el("setEventBtn");
  const pauseBtn = el("pauseBtn");
  const exportBtn = el("exportBtn");
  const importBtn = el("importBtn");
  const resetBtn = el("resetBtn");

  let svgRoot = null;
  let standMap = new Map();

  let rows = [];
  let selectedStandId = null;

  let autoSync = true;
  let syncTimer = null;
  let adminPassword = sessionStorage.getItem('admin_pwd') || '';
  let saveInFlight = false;

  // Pause auto-refresh while the user is editing fields (prevents resets mid-typing)
  function isEditing(){
    const ae = document.activeElement;
    return ae === companyEl || ae === statusEl || ae === eventNameEl;
  }

  function normalizeBackendUrl(input) {
    if (!input) return "";
    let s = String(input).trim();
    try {
      const u = new URL(s);
      let p = u.pathname.replace(/\/+$/,"");
      p = p.replace(/\/(api\/stands|stands)$/i, "");
      p = p.replace(/\/+$/,"");
      u.pathname = p ? p : "/";
      u.search = "";
      u.hash = "";
      const base = u.origin + (u.pathname === "/" ? "" : u.pathname);
      return base.replace(/\/+$/,"");
    } catch (e) {
      s = s.replace(/\/+$/,"");
      s = s.replace(/\/(api\/stands|stands)$/i, "");
      return s.replace(/\/+$/,"");
    }
  }

  function getBackendUrl() {
    const saved = localStorage.getItem(BACKEND_KEY);
    const base = (saved && saved.startsWith("http")) ? saved : DEFAULT_BACKEND;
    return normalizeBackendUrl(base);
  }

function showProgress(title, msg, frac){
  if (!progressOverlay) return;
  if (progressTitle) progressTitle.textContent = title || "Updating…";
  if (progressMsg) progressMsg.textContent = msg || "Please keep this tab open.";
  const f = Math.max(0, Math.min(1, Number(frac || 0)));
  if (progressBarFill) progressBarFill.style.width = `${Math.round(f*100)}%`;
  progressOverlay.style.display = "flex";
}
function hideProgress(){
  if (!progressOverlay) return;
  progressOverlay.style.display = "none";
  if (progressBarFill) progressBarFill.style.width = "0%";
}

function flashToast(message){
  if (!toast) return;
  if (toastMsg) toastMsg.textContent = message || "";
  if (toastActions) toastActions.style.display = "none";
  toast.style.display = "flex";
  setTimeout(() => {
    toast.style.display = "none";
    if (toastActions) toastActions.style.display = "";
  }, 1800);
}

function showToast(show) {
    toast.style.display = show ? "flex" : "none";
  }

  setBackendBtn.addEventListener("click", () => {
    const current = getBackendUrl();
    const v = prompt("Paste your backend URL (Cloudflare Worker or Google Apps Script Web App):", current);
    if (v && v.trim().startsWith("http")) {
      localStorage.setItem(BACKEND_KEY, v.trim().replace(/\/+$/,""));
      location.reload();
    }
  });
  hideToastBtn.addEventListener("click", () => showToast(false));

  async function fetchJson(url, opts = {}) {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), 12000);
    try {
      const res = await fetch(url, { ...opts, signal: controller.signal, cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } finally {
      clearTimeout(t);
    }
  }
  function ensureAdminPassword(opts = {}) {
  const force = !!opts.force; // if true, always ask again
  const reason = String(opts.reason || "save changes");
  const alreadyOk = adminPassword && adminPassword.trim();

  // If we haven't prompted yet on this page load, require a prompt once
  if (!force && hasPromptedPassword && alreadyOk) return adminPassword;

  const entered = prompt(`Admin password required to ${reason}:`, (alreadyOk ? adminPassword : rememberedPassword) || "");
  if (entered === null) return null; // cancelled
  const pwd = String(entered || "").trim();
  if (!pwd) return null;

  adminPassword = pwd;
  hasPromptedPassword = true;
  sessionStorage.setItem("admin_pwd", adminPassword);
  return adminPassword;
}

  function clearAdminPassword(){
    adminPassword = "";
    sessionStorage.removeItem("admin_pwd");
  }


  function normStandId(s){ return String(s||"").trim().toUpperCase(); }
  function normRow(row) {
    return {
      standId: normStandId(row.standId ?? row.stand ?? row.id),
      status: String(row.status || "available").toLowerCase(),
      company: String(row.company || "").trim()
    };
  }

  function normalizeDomId(id) {
    return String(id || "")
      .trim()
      .toUpperCase()
      .replace(/^STAND[_-]?/,"")
      .replace(/^ZONE[_-]?/,"")
      .replace(/^ID[_-]?/,"")
      .replace(/[^A-Z0-9]/g,"");
  }

  
function hitTestStandAtClient(clientX, clientY){
  if (!svgRoot) return null;
  const svg = svgRoot;
  const pt = svg.createSVGPoint();
  pt.x = clientX; pt.y = clientY;
  const ctm = svg.getScreenCTM();
  if (!ctm) return null;
  const sp = pt.matrixTransform(ctm.inverse());

  // Try geometry hit-test
  for (const [key, elem] of standMap.entries()){
    const geoms = [];
    if (elem instanceof SVGGeometryElement) geoms.push(elem);
    else geoms.push(...Array.from(elem.querySelectorAll("path,rect,polygon,polyline,circle,ellipse")));
    for (const g of geoms){
      try{
        if (typeof g.isPointInFill === "function" && g.isPointInFill(sp)) return key;
        if (typeof g.isPointInStroke === "function" && g.isPointInStroke(sp)) return key;
      }catch(e){}
    }
  }
  // Fallback bbox
  for (const [key, elem] of standMap.entries()){
    let bb=null;
    try{ bb = (elem.getBBox ? elem.getBBox() : null); }catch(e){ bb=null; }
    if (!bb) continue;
    if (sp.x >= bb.x && sp.x <= bb.x+bb.width && sp.y >= bb.y && sp.y <= bb.y+bb.height) return key;
  }
  return null;
}

function buildStandMap() {
    standMap.clear();
    if (!svgRoot) return;
    svgRoot.querySelectorAll("[id]").forEach(node => {
      const key = normalizeDomId(node.id);
      if (key && !standMap.has(key)) standMap.set(key, node);
    });
    svgRoot.querySelectorAll("[data-stand]").forEach(node => {
      const key = normalizeDomId(node.getAttribute("data-stand"));
      if (key && !standMap.has(key)) standMap.set(key, node);
    });
  }

  function elementForStand(standId){
    return standMap.get(normalizeDomId(standId)) || null;
  }

  function setFillForElement(elem, rgba) {
    if (!elem) return;
    const shapes = elem.matches("path,rect,polygon,polyline,ellipse,circle")
      ? [elem]
      : Array.from(elem.querySelectorAll("path,rect,polygon,polyline,ellipse,circle"));

    shapes.forEach(s => {
      const bbox = s.getBBox ? s.getBBox() : null;
      if (bbox && (bbox.width < 8 || bbox.height < 8)) return;
      s.style.fill = rgba;
      s.style.fillOpacity = "1";
    });
  }

  function clearCallout(){
    while (calloutSvg.firstChild) calloutSvg.removeChild(calloutSvg.firstChild);
    calloutSvg.style.display = "none";
    lozenge.style.display = "none";
    lozStand.textContent = "—";
    lozCompany.style.display = "none";
    lozCompany.textContent = "";
  }

  
  function setUndoEnabled(enabled) {
  if (!undoBtn) return;
  undoBtn.disabled = !enabled;
  undoBtn.style.opacity = enabled ? "1" : "0.45";
}

function updateUndoUI() {
  const n = undoStack.length;
  setUndoEnabled(n > 0);
  if (undoBtn) {
    undoBtn.textContent = n > 0 ? `Undo (${n})` : "Undo";
    undoBtn.title = n > 0 ? `Undo the last change (stack: ${n})` : "Undo the last change";
  }
}

function pushUndo(standId, prevSnapshot, nextSnapshot) {
  if (!standId || !prevSnapshot || !nextSnapshot) return;
  undoStack.unshift({ standId, prev: prevSnapshot, next: nextSnapshot, at: Date.now() });
  if (undoStack.length > UNDO_MAX) undoStack = undoStack.slice(0, UNDO_MAX);
  updateUndoUI();
}

async function undoLastChange() {
  if (!undoStack.length) return;

  const change = undoStack.shift();
  updateUndoUI();

  const pwd = ensureAdminPassword({ reason: "undo the last change" });
  if (!pwd) {
    // restore change if user cancelled
    undoStack.unshift(change);
    updateUndoUI();
    toast("Undo cancelled.", "info");
    return;
  }

  try {
    toast("Undoing…", "info");

    const res = await apiPost("/stand", {
      standId: change.standId,
      status: change.prev.status,
      company: change.prev.company,
      adminPassword: pwd,
    });

    if (!res.ok) {
      undoStack.unshift(change);
      updateUndoUI();
      toast(res.error || "Undo failed.", "error");
      return;
    }

    // Update local data to prev state
    const idx = stands.findIndex(s => String(s.standId).trim() === String(change.standId).trim());
    if (idx !== -1) {
      stands[idx] = { ...stands[idx], status: change.prev.status, company: change.prev.company };
    }

    // If currently selected stand is the one we undid, reflect it
    if ((selectedStandId || "") === change.standId) {
      statusEl.value = change.prev.status;
      companyEl.value = change.prev.company || "";
      updateCompanyFieldVisibility();
    }

    // Re-render list + recolor SVG
    renderStandList();
    colorizeSvgFromStands();

    toast("Undo complete.", "success");
    setSyncedNow();
  } catch (e) {
    undoStack.unshift(change);
    updateUndoUI();
    toast("Undo failed: " + (e && e.message ? e.message : e), "error");
  }
}
  async function loadSettings(){
    const backend = getBackendUrl();
    let settings = null;
    try{
      settings = await fetchJson(`${backend}/settings`);
    }catch(e){
      return;
    }
    const name = (settings && (settings.eventName || settings.name || settings.event || settings.title)) || "";
    if (name && eventNameEl) eventNameEl.value = String(name);
  }

  async function saveEventName(){
    if (!eventNameEl) return;
    const name = String(eventNameEl.value || "").trim();
    if (!name) { alert("Please enter an event name."); return; }

    // Must be user-triggered (Set button) so prompt works on iOS Safari
    ensureAdminPassword();

    const backend = getBackendUrl();
    let resp = null;
    try{
      resp = await fetchJson(`${backend}/settings`, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ eventName: name, adminPassword })
      });
    }catch(e){
      showToast(true);
      alert("Could not save event name (backend unreachable).");
      return;
    }

    if (resp && resp.ok === false){
      const msg = String(resp.error || "Event name save failed.");
      if (/invalid admin password/i.test(msg)){
        clearAdminPassword();
        alert("Incorrect admin password. Please try again.");
      } else {
        alert(msg);
      }
      return;
    }

    // Re-read settings to confirm (source of truth)
    await loadSettings();
    const after = String(eventNameEl.value || "").trim();
    if (after !== name){
      alert('Event name did not update on the backend (it reverted to: "' + after + '").');
    } else {
      syncedAt.textContent = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
    }
  }


  let settingsSaveTimer = null;
  function scheduleSaveEventName(){
    if (!eventNameEl) return;
    if (settingsSaveTimer) clearTimeout(settingsSaveTimer);
    settingsSaveTimer = setTimeout(async () => {
      const backend = getBackendUrl();
      const payload = { eventName: eventNameEl.value.trim() };
      try{
        await fetchJson(`${backend}/settings`, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });
        syncedAt.textContent = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
      }catch(e){
        showToast(true);
      }
    }, 600);
  }

  async function loadSvg() {
    const res = await fetch(SVG_URL, { cache: "no-store" });
    if (!res.ok) throw new Error("Could not load SVG");
    const txt = await res.text();
    svgHost.innerHTML = txt;
    svgRoot = svgHost.querySelector("svg");
    if (!svgRoot) throw new Error("SVG invalid");

    // Hide any stray huge circle at 0,0 (artifact)
    svgRoot.querySelectorAll("circle").forEach(c => {
      const cx = c.getAttribute("cx"), cy = c.getAttribute("cy"), r = parseFloat(c.getAttribute("r") || "0");
      if ((cx === "0" || cx === "0.0") && (cy === "0" || cy === "0.0") && r >= 20) {
        c.style.display = "none";
      }
    });

    svgRoot.setAttribute("preserveAspectRatio","xMidYMid meet");
    svgRoot.style.width = "100%";
    svgRoot.style.height = "auto";
    svgRoot.style.display = "block";

    // If stand numbers/text are on a separate layer, they can block clicks.
    // Make text/images ignore pointer events so clicks reach the stand shapes.
    svgRoot.querySelectorAll("text,image").forEach(n => {
      try{ n.style.pointerEvents = "none"; }catch(e){}
    });

    buildStandMap();
    // Visual hint: stands are clickable on desktop
    standMap.forEach((node) => { try{ node.style.cursor = "pointer"; }catch(e){} });

    // click-to-select
    svgRoot.style.pointerEvents = "auto";
    svgRoot.style.pointerEvents = "auto";
    // Ensure shapes receive pointer events (some SVGs disable this)
    svgRoot.querySelectorAll("path,rect,polygon,polyline,ellipse,circle,g").forEach(n => {
      try{ n.style.pointerEvents = "all"; }catch(e){}
    });

    
svgRoot.addEventListener("click", (ev) => {
  // First: try direct id in composed path / ancestors
  const path = (typeof ev.composedPath === "function") ? ev.composedPath() : null;
  const candidates = path && path.length ? path : [ev.target];

  for (const c of candidates){
    if (!c || !c.id) continue;
    const key = normalizeDomId(c.id);
    const found = rows.find(r => normalizeDomId(r.standId) === key);
    if (found){ selectStand(found.standId); return; }
  }

  // Second: robust hit test (fixes A2)
  const hitKey = hitTestStandAtClient(ev.clientX, ev.clientY);
  if (!hitKey) return;
  const found = rows.find(r => normalizeDomId(r.standId) === hitKey);
  if (found) selectStand(found.standId);
}, { passive:true });
  }

  async function loadData() {
    const backend = getBackendUrl();
    const data = await fetchJson(`${backend}/stands?ts=${Date.now()}`);
    rows = (Array.isArray(data) ? data : []).map(normRow).filter(r => r.standId);

    applyColours();
    renderTable();

    syncedAt.textContent = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
    showToast(false);

    // keep selection after refresh
    if (selectedStandId) {
      const row = rows.find(r => r.standId === selectedStandId);
      if (row) {
        statusEl.value = row.status;
        companyEl.value = row.company || "";
        drawCallout(row.standId);
      }
    }
  }

  async function saveCurrent() {
    const pwdOk = ensureAdminPassword({ reason: "save changes" });
    if (!pwdOk) return;
    saveInFlight = true;
    if (!selectedStandId) { saveInFlight = false; return; }
    const backend = getBackendUrl();

    const standId = selectedStandId;
    const nextStatus = statusEl.value;
    const nextCompany = (nextStatus === "sold") ? companyEl.value.trim() : "";

    // Snapshot previous + next values for Undo
    const prevIdx = rows.findIndex(r => r.standId === standId);
    const prevSnapshot = (prevIdx >= 0)
      ? { standId, status: rows[prevIdx].status, company: (rows[prevIdx].company || "") }
      : { standId, status: "available", company: "" };
    const nextSnapshot = { standId, status: nextStatus, company: nextCompany };

    const payload = {
      standId,
      status: nextStatus,
      company: nextCompany,
      adminPassword: adminPassword
    };

    try{
      const resp = await fetchJson(`${backend}/stand`, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
    
      if (resp && resp.ok === false){
        const msg = String(resp.error || "Save failed.");
        if (/invalid admin password/i.test(msg)){
          clearAdminPassword();
          alert("Incorrect admin password. Please try again.");
        } else {
          alert(msg);
        }
        return;
      }

      // Record last change for Undo
      pushUndo(standId, prevSnapshot, nextSnapshot);
}catch(e){
      showToast(true);
      return;
    }finally{
      saveInFlight = false;
    }

    const idx = rows.findIndex(r => r.standId === selectedStandId);
    if (idx >= 0) rows[idx] = { ...rows[idx], standId, status, company };

    applyColours();
    renderTable();
    drawCallout(selectedStandId);

    // Pull fresh data back from backend (authoritative) to prevent reverts
    try{ await loadData(); }catch(e){}
    syncedAt.textContent = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
  }

  async function resetAll() {
  if (!rows.length) return;

  const pwd = ensureAdminPassword({force:true, reason:"Reset all"});
  if (!pwd) return;

  // Pause auto-sync while resetting to avoid clashes
  const wasAutoSync = autoSync;
  autoSync = false;
  stopPolling();

  const ok = confirm("Reset SVG stands to Available? This will overwrite sold stands on the plan.");
  if (!ok) return;

  resetBtn.disabled = true;
  const backend = getBackendUrl();

  // Only reset stands that exist in the SVG
  const targets = rows.filter(r => !!elementForStand(r.standId));
  const total = targets.length;

  try{
    for (let i=0;i<total;i++){
      const r = targets[i];
      showProgress("Resetting stands…", `Updating ${i+1} of ${total} (${r.standId})`, (i+1)/total);

      const payload = { standId: r.standId, status:"available", company:"", adminPassword: pwd };
      const resp = await fetchJson(`${backend}/stand`, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });

      if (resp && resp.ok === false){
        hideProgress();
        alert(String(resp.error || "Reset failed."));
        resetBtn.disabled = false;
        return;
      }

            // small delay to avoid Apps Script rate limits
      await new Promise(r => setTimeout(r, 120));

      // update local copy
      const idx = rows.findIndex(x => x.standId === r.standId);
      if (idx >= 0) rows[idx] = { standId: r.standId, status:"available", company:"" };
    }

    hideProgress();
    resetBtn.disabled = false;

    applyColours();
    renderTable();
    clearCallout();
    selectedStandId = null;
    standIdEl.value = "";
    statusEl.value = "available";
    companyEl.value = "";
    syncedAt.textContent = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});

    flashToast("Reset complete ✅");
    autoSync = wasAutoSync;
    if (autoSync) startPolling();
  }catch(e){
    hideProgress();
    resetBtn.disabled = false;
    showToast(true);
    console.error(e);
    autoSync = wasAutoSync;
    if (autoSync) startPolling();
  }
}

  // Events
  saveBtn.addEventListener("click", saveCurrent);
  if (setEventBtn){
    setEventBtn.addEventListener("click", (e) => {
      e.preventDefault();
      saveEventName();
    });
  }
  // Press Enter in the Company field to save
  companyEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      e.preventDefault();
      saveCurrent();
    }
  });
  markAvailBtn.addEventListener("click", () => {
    statusEl.value = "available";
    companyEl.value = "";
    saveCurrent();
  });

  undoBtn && undoBtn.addEventListener("click", undoLastChange);
  
    updateUndoUI();
setUndoEnabled(false);

  searchEl.addEventListener("input", renderTable);
  filterEl.addEventListener("change", renderTable);
  pauseBtn.addEventListener("click", () => {
    autoSync = !autoSync;
    pauseBtn.textContent = autoSync ? "Pause sync" : "Resume sync";
    if (autoSync) startPolling(); else stopPolling();
  });

  exportBtn.addEventListener("click", () => {
    const _pwd = ensureAdminPassword({force:true, reason:"Export CSV"});
    if (!_pwd) return;

    const lines = ["standId,status,company"].concat(rows.map(r => {
      const c = (r.company||"").replaceAll('"','""');
      return `${r.standId},${r.status},"${c}"`;
    }));
    const blob = new Blob([lines.join("\n")], { type:"text/csv" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "stands.csv";
    a.click();
    URL.revokeObjectURL(a.href);
  });

  
importBtn.addEventListener("click", () => {
  // Pick file first, then ask for password (so Cancel doesn't still open Finder)
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = ".csv,text/csv";
  inp.onchange = async () => {
    const f = inp.files && inp.files[0];
    if (!f) return;

    const _pwd = ensureAdminPassword({ force:true, reason:"Import CSV" });
    if (!_pwd) return;
    undoStack = []; updateUndoUI();

    const backend = getBackendUrl();

    // Stop polling while we apply a batch update (otherwise it will overwrite the imported changes)
    const wasAuto = autoSync;
    autoSync = false;
    stopPolling();
    pauseBtn.textContent = "Resume sync";

    try{
      const txt = await f.text();
      const lines = txt.split(/\r?\n/).filter(Boolean);
      const out = [];
      for (let i=1;i<lines.length;i++){
        const line = lines[i];
        const m = line.match(/^([^,]+),([^,]+),"(.*)"$/);
        if (!m) continue;
        out.push({
          standId: normStandId(m[1]),
          status: String(m[2]||"").trim().toLowerCase(),
          company: (m[3]||"").replaceAll('""','"')
        });
      }

      if (!out.length){
        flashToast("CSV had no rows to import.");
        return;
      }

      showProgress("Importing CSV to Google Sheet…", 0, out.length);

      // Apply each row to the backend (Google Sheet is source of truth)
      for (let i=0;i<out.length;i++){
        const r = out[i];
        const payload = {
          standId: r.standId,
          status: (r.status === "sold") ? "sold" : "available",
          company: (r.status === "sold") ? (r.company||"").trim() : "",
          adminPassword: _pwd
        };

        await fetchJson(`${backend}/stand`, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify(payload)
        });

        // progress
        showProgress("Importing CSV to Google Sheet…", i+1, out.length);

        // tiny yield keeps UI responsive on big imports
        await new Promise(res => setTimeout(res, 30));
      }

      hideProgress();
      flashToast("Import complete.");

      // Reload from backend (source of truth)
      await loadData();

    }catch(e){
      console.error(e);
      hideProgress();
      showToast(true);
      flashToast("Import failed (check password / backend).");
    }finally{
      // Restore polling state to what it was
      autoSync = wasAuto;
      pauseBtn.textContent = autoSync ? "Pause sync" : "Resume sync";
      if (autoSync) startPolling();
    }
  };
  inp.click();
});


resetBtn.addEventListener("click", resetAll);

  window.addEventListener("scroll", () => { if (selectedStandId) drawCallout(selectedStandId); }, { passive:true });
  window.addEventListener("resize", () => { if (selectedStandId) drawCallout(selectedStandId); });

  function startPolling(){
    stopPolling();
    syncTimer = setInterval(async () => {
      if (!autoSync) return;
      if (isEditing()) return; // don't refresh while typing/choosing
      if (saveInFlight) return; // don't refresh while saving
      try { await loadData(); await loadSettings(); } catch(e){ showToast(true); }
    }, 8000);
  }
  function stopPolling(){
    if (syncTimer) clearInterval(syncTimer);
    syncTimer = null;
  }

  // init
  (async () => {
    try{
      const ok = await requireAdminPassword();
      if (!ok) { setStatus('Password required.'); return; }
      await loadSettings();
      await loadSvg();
      layoutMobile();
      await loadSettings();
    }catch(e){
      showToast(true);
      console.error(e);
      return;
    }
    try{
      if (!isEditing()) await loadData();
      startPolling();
    }catch(e){
      showToast(true);
      console.error(e);
    }
  })();
})();

  function layoutMobile(){
    // Only on small screens
    if (window.matchMedia && !window.matchMedia('(max-width: 640px)').matches) return;
    const plan = document.querySelector('.planCard');
    const selected = document.getElementById('selectedCard');
    const tableWrap = document.getElementById('tableWrap');
    if (!plan || !selected || !tableWrap) return;

    // Compute top offset for selected card just below plan card
    const planRect = plan.getBoundingClientRect();
    // planRect.top should be 0 when sticky; use its height
    const top = Math.round(planRect.height + 12); // small gap
    selected.style.top = top + 'px';

    // Compute available height for tableWrap (viewport minus header minus sticky blocks)
    const header = document.querySelector('header');
    const headerH = header ? header.getBoundingClientRect().height : 0;

    // Heights of sticky blocks (planCard includes its own header, plan, label bay, legend)
    const planH = plan ? plan.getBoundingClientRect().height : 0;
    const selectedH = selected ? selected.getBoundingClientRect().height : 0;

    // Leave a little breathing room
    const available = Math.max(200, window.innerHeight - headerH - planH - selectedH - 24);

    tableWrap.style.maxHeight = available + 'px';
  }


</script>
</body>
</html>
